\documentclass[finnish,gradu]{tktltiki}
\usepackage{ae,aecompl}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{color}
\usepackage{graphicx}

% MEMO:
%   Teksti etenee kuin haluaisi hyvän oppikirjan etenevän.
%   Käsitteet määritellään.
%   Kun käsite ekaa kertaa: italics.
%
% TODO:
%   Kiitokset!
%    - ESO
%    - TKTL, CSP-TiViT
%    - Fratello hyvä kahvi
%


\begin{document}

\title{Internet-skaalan identiteetti:
    \\ ''Case-study kertakirjautumisesta virtuaalikurssille.''}

\author{Petrus Repo}
\date{\today}
\level{G!}
\maketitle


\onehalfspacing

\level{Graduluonnos}
\faculty{Matemaattis-luonnontieteellinen}
\department{Tietojenkäsittelytieteen laitos}
\subject{Tietojenkäsittelytiede}
\numberofpagesinformation{\numberofpages\ sivua}

\keywords{OpenID, OAuth, SAML, internet, autentikointi, auktorisointi}

\begin{abstract}

  \begin{verbatim}




                                                            ___
                                                         ,o88888
                                                      ,o8888888'
                                ,:o:o:oooo.        ,8O88Pd8888"
                            ,.::.::o:ooooOoOoO. ,oO8O8Pd888'"
                          ,.:.::o:ooOoOoOO8O8OOo.8OOPd8O8O"
                         , ..:.::o:ooOoOOOO8OOOOo.FdO8O8"
                        , ..:.::o:ooOoOO8O888O8O,COCOO"
                       , . ..:.::o:ooOoOOOO8OOOOCOCO"
                        . ..:.::o:ooOoOoOO8O8OCCCC"o
                           . ..:.::o:ooooOoCoCCC"o:o
                           . ..:.::o:o:,cooooCo"oo:o:
                        `   . . ..:.:cocoooo"'o:o:::'
                        .`   . ..::ccccoc"'o:o:o:::'
                       :.:.    ,c:cccc"':.:.:.:.:.'
                     ..:.:"'`::::c:"'..:.:.:.:.:.'
                   ...:.'.:.::::"'    . . . . .'
                  .. . ....:."' `   .  . . ''
                . . . ...."'
                .. . ."'
               .

  \end{verbatim}

\end{abstract}

\setcounter{tocdepth}{3}
\mytableofcontents

\section{Johdanto} % (fold)
\label{sec:johdanto}

  Helsingin yliopiston tietojenkäsittelytieteen laitos järjestää ohjelmoinnin avointa virtuaaliopetusta. Opetus tapahtuu niin sanotussa \emph{Massive Online Open Course} (MOOC) -formaatissa (todo alaviite), jossa kuka tahansa ja mistä päin maailmaa tahansa voi hyväksytysti suorittaa kurssiin. Opiskelijalla ei tarvitse olla Helsingin yliopiston opiskeluoikeutta eikä siten myöskään Helsingin yliopiston verkkoympäristön käyttäjätunnusta. MOOC-järjestelmä tarvitsee kuitenkin luotettavan tavan käyttäjän identiteetin varmistamiseksi eli \emph{autentikoimiseksi}.

  MOOC-palvelun nykyisessä toteutuksessa on jokaiselle käyttäjälle oma käyttäjätunnus ja salasana. Käyttäjätunnus on MOOC-palvelun sisäisen toteutus, jota ei ole kytketty muihin järjestelmiin. MOOC-palvelun nykyisestä toteutuksesta eli omasta tunnus/salasana-yhdistelmästä halutaan eroon, koska käyttäjätunnusten hallinta aiheuttaa liikaa ylläpitotyötä ja ylläpitotyön määrä lisääntyy opiskelijamäärän kasvaessa. Nykyisellään autentikointia ei ole erotettu SOA-arkkitehtuurimallin mukaisesti itsenäiseksi palveluksi (kuva~\ref{fig:mooc-arkkitehtuuri}), vaan autentikoinnin toteutus on kytketty tiukasti (\emph{tightly coupled}) palvelun muuhun toteutukseen. Itsenäinen autentikointipalvelu olisi yksi toteutusvaihtoehto -- mutta se ei varsinaisesti vähennä ylläpitotyön kokonaismäärää vaan pikemminkin tuottaa sitä lisää.

  \begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/mooc-arkkitehtuuri.jpg}
    \caption{MOOC-palvelun nykyinen ja SOA-mallin mukainen arkkitehtuuri}
    \label{fig:mooc-arkkitehtuuri}
  \end{figure}


  Kuva~\ref{fig:yleiskuva_termien_suhteista} esittelee tutkielmaan liittyvien autentikoinnin toimijoiden välisiä suhteita. Ylimpänä on identiteettiään hallinnoiva loppukäyttäjä, eli ihminen, joka ottaa käyttäjäagentillaan yhteyden esimerkiksi GMail-palveluun. GMail-palvelu on identiteetinkuluttja (\emph{identity consumer}), joka pitää hallussaan käyttäjän yksilöivää tunnistetta (\emph{identifier}) -- vaan ei varmennetta (\emph{credentials}). Varmenne voi olla esimerkiksi salasana, joka vahvistetaan yhteentoimivuuden standardin avulla identiteetintarjoajan (\emph{identity provider}) palvelussa. Varmenteen vahvistaminen on identiteetintarjoajan sisäinen toteutus, johon tutkielmassa ei oteta kantaa. Yleisiä toteutuksia siihen ovat esimerkiksi Kerberos-tiketit ja salasanan tiivisteen tallettaminen tietokantaan tai LDAP-palveluun.

  \begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{images/auth_yleiskuva.jpg}
    \caption{Tutkielman liittyvien termien väliset suhteet}
    \label{fig:yleiskuva_termien_suhteista}
  \end{figure}


  Tutkielma esittelee kolme yhteiskäytön standardia (\emph{interoperability standards}), jotka mahdollistavat käyttäjän identiteetin varmistamisen hajautetussa verkkoympäristössä. Tutkielma ei ota kantaa järjestelmien sisäiseen toteutukseen, mutta kuvailee yksityiskohtaisesti standardien arkkitehtuuria relevantein osin. Esiteltävät standardit ovat julkisissa web-palveluissa yleistyneet OpenID 2.0 ja OAuth 2.0 (luonnos 22) sekä yritysten sisäverkoissa suosittu SAML 2.0. Jokaiseen standardiin esitellään sopiva identiteetintarjoaja, jolle voidaan ulkoistaa käyttäjän autentikointi (kuva~\ref{fig:mooc-autentikointirajapinnat}). Lopputuloksena on palvelun käyttäjämäärän kasvattaminen ilman, että käyttäjien autentikointitietojen hallinnasta koituu lisätyötä MOOC-kurssin vastuuhenkilöille. Tällöin MOOC-kurssin vetäjät voivat keskittyä ydintehtäviinsä eli virtuaaliopetuksen tarjoamiseen ja varsinaisen virtuaaliopetusalustan toteuttamiseen.


  \begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{images/mooc-autentikointirajapinnat.jpg}
    \caption{MOOC-palveluun toteutettavat autentikointirajapinnat}
    \label{fig:mooc-autentikointirajapinnat}
  \end{figure}


% section johdanto (end)


\section{Ulkoinen identiteetintarjoaja web-palvelun sisäänkirjautumisessa} % (fold)
\label{sec:ulkoisen_identiteettipalvelun_käyttö_web_palvelun_sisäänkirjautumisessa}

MOOC:n lähtökohtana on nimensä mukaisesti olla valtava (\emph{massive}). Jos virtuaalikurssi muodostuu suosituksi täytyy kuormitukseen liittyvät pullonkaulat tunnistaa. Kun toimintojen vastuualueet on SOA-mallin mukaan jaettu omiksi palveluikseen, skaalaminen on monoliittista järjestelmää suoraviivaisempaa. Valtavuuden vuoksi on houkuttelevaa ulkoistaa identiteetintarjoajan vastuualue täysin kolmannelle osapuolelle kuten Helsingin yliopistolle, Googlelle tai Facebookille. Helsingin yliopistolla on noin 40.000 käyttäjätunnusta\footnote{Helsingin yliopistolla 35.000 opiskelijaa ja 4.000 henkilökunnan jäsentä (\url!http://www.helsinki.fi/lyhyesti/!)}. Facebookilla ja Googlella yhteensä yli 1,1 miljardia käyttäjätunnusta\footnote{Facebookilla 800 miljoonaa käyttäjää (\url!https://www.facebook.com/press/info.php?statistics!), Googlen Gmail-palvelulla 350 miljoonaa käyttäjää (\url!http://en.wikipedia.org/wiki/Gmail!)}. Pelkästään kahden jälkimmäisen kautta iso prosenttiosuus MOOC-palvelun käyttäjistä saataisiin autentikoitua -- erityisesti koska kurssi on avoin kaikille.


\subsection{Web ja SaaS ilmiöinä} % (fold)

\label{sub:web_ja_saas}

  \begin{quote}
    ''The future is already here -- it's just not very evenly distributed.''
    \\ --- William Gibson, 1993
    % http://en.wikiquote.org/wiki/William_Gibson
  \end{quote}

  \emph{Web 2.0} oli yleinen muotisana vuosina 2005--2008. Perinteinen web, ''versio 1.0'' oli staattinen, yksisuuntainen ja täysin palvelinpään hallinnassa. Versionumerolla \emph{2.0} kuvastettiin uutta ajatusmaailmaa, jossa sivuston sisältö ei enää olisi suljettu, vaan tietoa pystyisi tuomaan järjestelmään käyttäjän selaimesta -- parhaimmillaan ilman, että koko web-sivua tarvitsi ladata uudelleen. Trendin keskeisin piirre oli kuitenkin selainpohjaisuus: sisällön lukemiseksi ja tuottamiseksi ei selaimen lisäksi tarvitsisi asentaa muuta erillistä natiivisovellusta.

  % web = web 2.0 + saas + cloud
  2010-luvulla Web 2.0:n ovat syrjäyttäneet trendikkäämmät termit kuten \emph{SaaS} (\emph{Software-as-a-Service}) ja \emph{pilvi} (\emph{cloud}). Termit eivät suoranaisesti korvaa Web 2.0:aa, mutta niillä on paljon yhteistä. Pilvi on käsitteenä häilyvä ja voi tarkoittaa eri yhteyksissä erilaisia asioita. Pilven keskeisin teesi on kuitenkin \emph{kapasiteetiltaan rajattoman laitteiston käyttö palveluna}. Perinteisesti laitteiston virtualisointi on kytketty ennalta määritettyyn kapasiteettiin, joka vuokrataan ennalta määrätyksi ajaksi, esimerkiksi kuukaudeksi tai vuodeksi kerrallaan. Pilvessä kapasiteettia voidaan kuitenkin ottaa käyttöön dynaamisesti, jolloin lisäkapasiteettia tarvitsee parhaimmillaan vuokrata vain kuormituspiikin ajaksi. Esimerkiksi laskentaintensiiviset tai eräajona suoritettavat ohjelmistot on houkuttelevaa hajauttaa pilveen: kustannus ajaa yhtä konetta 1000 tuntia voi olla sama kuin ajaa 1000:a konetta yksi tunti -- mutta jälkimmäisellä tavalla tulos valmistuu nopeammin.

  % IaaS ja PaaS: Ei käsitellä tässä tutkielmassa.
  SaaS on pilven kulma, jonka teesinä on ohjelmiston tarjoaminen palveluna loppukäyttäjälle. Web 2.0:aa edeltävänä aikana oli tyypillistä asennuttaa ohjelmisto natiivisovelluksena työasemalle. Koska ohjelmisto on SaaS-ajatusmallissa palvelu, sen käyttämiseksi riittää \emph{käyttäjäagentti} (\emph{user-agent}) (todo termi), joka tyypillisesti on web-selain tai natiivi mobiilisovellus. Merkittävänä hyötynä on ylläpidon vaatiman työmäärän pieneneminen: palveluntuottajan riittää varmistaa yhteensopivuus eri käyttäjäagenttien kesken ja asentaa ohjelmistopäivitykset ainoastaan itsensä hallinnoimaan ohjelmistoympäristöön. Käyttäjäagentin -- kuten web-selaimen -- päivittäminen on loppukäyttäjän vastuulla. 2010-luvulla ''web'' on edelleen ajankohtainen termi, mutta sen merkitys on aiempaa monipuolisempi.

  % Ihanteellisesti SaaS-ajatusmaailmassa palvelun toimintalogiikka on samanlainen kaikille sen asiakkaille. Palvelun kustannukset per asiakas saadaan sitä pienemmäksi, mitä vähemmän palvelussa on asiakaskohtaisia muutoksia. Taloudellisuus on edellytys palvelun skaalautumiseksi laajalle käyttäjäjoukolle. Perinteisen ohjelmistolisenssin sijasta asiakas maksaa siis käyttömaksua. % multitenanttius

  Palveluntuottajan kannalta SaaS tarjoaa mahdollisuuden käyttää valmista ja \emph{ylläpidettyä} ratkaisua oman toteutuksen sijaan. Ohjelmistokehittäjä voi keskittää ajankäyttönsä oman palvelunsa kannalta relevanttien ongelmien ratkaisemiseen itse ja ostaa kaiken muun palveluna. Ohjelmistokehitys- ja ylläpitotyön lisäksi palveuntuottajan ei varsinkaan tarvitse ylläpitää palvelinlaitteistoa -- fyysistä tai virtualisoituakaan. Ohjelmistokehittäjälle pilvi tarjoaa myös kaksi muuta relevanttia kulmaa -- IaaS (\emph{Infrastructure-as-a-Service}) ja PaaS (\emph{Platform-as-a-Service}) -- mutta niihin emme tässä tutkielmassa pureudu tätä syvemmälle.

  % section web_ja_saas (end)

  \subsection{Web ja rajapinnat} % (fold)
  \label{sub:web_ja_rajapinnat}

  \begin{quote}
    ''It is not the strongest of the species that survive, nor the most intelligent, but the ones most responsive to change.'' --- Darwin (todo viite) (kräp, lainaus ei oikeasti darwin)
    % ei oikeasti darwin,
    % The earliest known appearance of this basic statement is a paraphrase of Darwin in the writings of Leon C. Megginson, a management sociologist at Louisiana State University.
  \end{quote}

  Webin ytimessä on HTTP-protokolla. Vain merkittyksettömän pieni osa webin liikenteestä tapahtuu jollain muulla tiedonsiirtomenetelmällä (todo poista tai täsmennä, esim eri asia torrentit ja web). Toistaiseksi web-selain on yleisin sovellus, jolla webiä käytetään. Mobiilin internetin yleistyminen saattaa muuttaa tilannetta, jos tulevaisuudessa suurin osa mobiilista internetkäytöstä tapahtuu natiiveilla mobiilisovelluksilla eikä mobiiliselaimella. Morgan \& Stanley ennustaa, että vuoteen 2014 mennessä internetiä käytetään enemmän mobiilipäätelaitteilla kuin perinteisillä työasemilla (viite \verb!http://www.morganstanley.com/institutional/techresearch/pdfs/Internet_Trends_041210.pdf!). Tämä korostaa tarvetta \emph{rajapinnoille} (\emph{Application Programming Interface, API}), joiden kautta palveluntuottajan tietoihin päästään käsiksi.

  Rajapinta mahdollistaa vuorovaikutuksen palveluntuottajan ja palveluntuottajasta riippumattomien ohjelmistokehittäjien välillä. Rajapinta helpottaa pääsyä tietoon, koska tieto on ohjelmistokehittäjän käytettävissä valmiiksi jäsennellyssä muodossa eikä tietoa tarvitse suodattaa esimerkiksi suuresta rakenteettomasta tekstimassasta. Tällöin myös palveluntuottajasta riippumattomat ohjelmistokehittäjät voivat luoda yhdistelmiä (\emph{mashups}) eri palvelujen tarjoamista tiedoista. Tiedon avaaminen rajapinnan kautta mahdollistaa uusien palvelujen ja parhaimmillaan kokonaisen ekosysteemin kehittymisen palveluntuottajan ympärille. Rajapinta voi tarjota tietoa ilmaiseksi tai kaupallisella lisenssillä. Rajpaintojen kautta voidaan jakaa kaikki mahdollinen data tai tietoa voidaan tarjota vain rajoitetusti. Tiedon näkyvyyttä ja käyttötapaa hallinnoidaan pääsyoikeuksilla.

  Ohjelmistoon kohdistuvat vaatimukset tyypillisesti elävät (muuttuvat) sekä kehityksen että ylläpitovaiheen aikana. Darwinin lainauksen mukaisesti muutoskykyisyys on edellytys selviämiselle. Palveluorientoitunut arkkitehtuuri (\emph{Service Oriented Architecture, SOA}) on voimakas tapa varautua muuttuviin vaatimuksiin. SOA-periaatteena on toteuttaa yhden monoliittisen kokonaisuuden sijasta lukuisia pienempiä palveluja, joista jokaisella on oma tiukasti rajattu vastuualueensa. Tavoitteena on palvelujen välinen löyhä kytkentä (\emph{loose coupling}), jolloin muutokset yhdessä palvelussa eivät vaikuta muihin palveluihin. Palveluorientoituneessa arkkitehtuurissa palvelut keskustelevat keskenään rajapintojen kautta.

  % subsection web_ja_rajapinnat (end)



  \subsection{Identiteetti internetissä} % (fold)
  \label{sub:identiteetti_internetissä}

  Ihmisellä monta erilaista profiilia internetissä. Työpaikan-, vapaa-ajan- ja opiskelun profiili. Jokainen profiili luo omanlaisensa identiteetin (tarkenna). On tyypillistä hyväksyä LinkedIn-yhteisöpalveluun työkontakteja, joiden kanssa on ainoastaan jakanut käyntikortin. Facebook-kavereiksi sen sijaan ei yleensä haluta pomoa tai kaukaisempia työkavereita, koska vapaa-ajan tekemiset halutaan pitää erillään työpaikasta. Vastaavasti opiskeluihin on tyypillistä käyttää oppilaitoksen myöntämää sähköpostiosoitetta, johon tavanomaisesti kirjaudutaan oppilaitoksen myöntämällä käyttäjätunnuksella.

  Käyttäjäkeskeisen identiteetin periaatteen mukaan käyttäjällä täytyy olla mahdollisuus valita, minkä identiteeteistänsä hän yhdistää johonkin web-palveluun~\cite{openid_recordon_2009}. Toteutuakseen käytännössä periaate tarkoittaa, että web-palvelun on mahdollistettava sisäänkirjautuminen monen eri identiteetintarjoan avulla. Käyttäjän kannalta ei ole samantekevää, pääseekö web-palveluun kirjautumaan ainoastaan Facebook-tunnuksilla, jos käyttäjä itse ei tahdo olla Facebook-palvelun asiakas.

  Federoitu identiteetti on toinen periaate, joka ei kuitenkaan ole poissulkeva käyttäjäkeskeisyyden suhteen. Federaatioksi kutsutaan joukkoa toimijoita, jotka luottavat toisiltansa saaman tietynlaisen tiedon olevan oikeellista (todo termi, valid)~\cite{id_in_federation_systems_2005}. Käyttäjän tunnistamisen osalta tunnistamista pyytänyt identiteetinkuluttaja (federaation jäsen) luottaa identiteetintarjoajan viestiin siitä, että käyttäjä vahvistanut hallitsevansa esittämäänsä käyttäjätunnusta. Identiteetinkuluttaja on siten valtuuttanut identiteetintarjoajan toimimaan käyttäjiensä identiteetin varmentajana eli tarjoamaan käyttäjälle federoidun identiteetin.

  Palvelujen välisen luottamussuhteen laatu riippuu tapauksesta -- lähtökohtaisesti luottamus on mahdollisimman vähäinen tietoturvariskien minimoimiseksi. Vaikka identiteetinkuluttaja luottaa identiteetintarjoajan autentikointiviestiin, kuluttaja voi turvallisuuden lisäämiseksi soveltaa monivaiheista autentikointia esimerkiksi kysymällä lisäksi omaa palvelukohtaista salasanaa. OAuth- tai OpenID-spesifikaatio ei ota kantaa siihen, kuinka identiteetintarjoajan on autentikoitava käyttäjä: on siis mahdollista tehdä identiteetintarjoaja, joka ei autentikoi lainkaan vaan varmentaa minkä tahansa tunnisteen. Tästä syystä OpenID-identiteetinkuluttajan ja -tarjoajan ei lähtökohtaisesti ole minkäänlaista luottamusta, jolloin luottamuksen saavuttamiseksi kuluttajan voi olla syytä hyväksyä ainoastaan ennaltamääritetty joukko OpenID-identiteetintarjoajia.

  Identiteetinkuluttajalla voi olla käyttäjilleen paikallinen tunniste, joka yhdistetään identiteetintarjoajan federoidun identiteetin tunnisteeseen~\cite{id_delegation_2005}. Tällöin eri identiteetintarjoajien tunnisteet eivät koskaan törmää paikallisen käyttäjätunnuksen kanssa. Käyttäjälle voidaan myös antaa vapaus valita oma paikallinen käyttäjätunnuksensa ja sitä kautta muodostaa oma MOOC-identiteetti, vaikka autentikointi tapahtuu identiteetintarjoajan palvelussa. MOOC-palvelun käyttäjän identiteetintarjoaja voidaan pitää vain MOOC-palvelun tiedossa eli olla näyttämättä sitä muille käyttäjille. Tällöin käyttäjä voi halutessaan säilyttää yksityisyytensä, vaikka hän käyttäisi sisäänkirjautumisessa Facebook-tunnustansa. Kuvassa~\ref{fig:uid_mapping} on esitetty identiteetinkuluttajan paikallisen käyttäjätunnisteen kytkeminen federoidun identiteetin tunnisteeseen identiteetintarjoajan päässä.

  \begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{images/uid_mapping.jpg}
    \caption{Identiteetinkuluttajalla (idc) on itsenäiset käyttäjätunnisteet, joihin identiteetintarjoajien (idp) käyttäjätunnisteet kytketään.}
    \label{fig:uid_mapping}
  \end{figure}

  Eri järjestelmien pitää toimia keskenään yhteen, jotta sama identiteetti voidaan jakaa toisistaan riippumattomien palvelujen kesken. Tarve yhteiskäyttöiselle standardille.


    % 7 Laws of Identity.
    % % Microsoftin visio identiteetistä. Miksi .NET Passport epäonnistui?
    % Miksei OpenID yleistynyt?
    % Miksi Facebook koetaan uhkana? (vrt 2500 sivua dataa keskivertokansalaisesta vs kgb/cia vs eu-lait)
    % Miksei Facebook-tunnusta voi käyttää kaikkialla?
    %
    % Fyysisen laitteen vaativat tekniikat, niiden ongelmat. (HST-kortti, SIM-kortti)

    % Hyllytetyt aiheet:
    % Directed Identity
    % Korttiperusteinen identiteetti (card-based identity)
    % Luottamusmalli (Trust Model)
    %     Milloin tarvitaan trust model? Kun halutaan vaihtaa dataa palvelujen kesken? Onko Facebook Connectissa Trust Model?

  % subsection identiteetti_internetissä (end)


  % \subsection{HTTP-protokolla} % (fold)
  % \label{sub:http_protokolla}
  %
  % rfc 2068, http/1.1
  %
  % Practical information systems require more functionality than simple
  %    retrieval, including search, front-end update, and annotation. HTTP
  %    allows an open-ended set of methods that indicate the purpose of a
  %    request. It builds on the discipline of reference provided by the
  %    Uniform Resource Identifier (URI) [3][20], as a location (URL) [4] or
  %    name (URN) , for indicating the resource to which a method is to be
  %    applied.
  %
  %    HTTP is also used as a generic protocol for communication between
  %      user agents and proxies/gateways to other Internet systems, including
  %      those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],
  %      and WAIS [10] protocols. In this way, HTTP allows basic hypermedia
  %      access to resources available from diverse applications.
  %
  % HTTP on request/response-protokolla. Tilaton.
  %
  % URIs in HTTP can be represented in absolute form or relative to some
  %    known base URI, depending upon the context of their use. The two
  %    forms are differentiated by the fact that absolute URIs always begin
  %    with a scheme name followed by a colon.
  %
  % RFC kpl 1.4
  %
  % HTTP 1.1 -pyyntö:
  % \begin{verbatim}
  %   GET /resurssi HTTP/1.1
  %   Host: verkkotunnus.com
  % \end{verbatim}
  %
  % Tässä  /resurssi kuvastaa suhteellista request-URI:a ja GET on verbi.
  %
  % The absoluteURI form is required when the request is being made to a proxy. The proxy is requested to forward the request or service it from a valid cache, and return the response.
  % GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
  %
  % The most common form of Request-URI is that used to identify a
  %    resource on an origin server or gateway. In this case the absolute
  %    path of the URI MUST be transmitted (see section 3.2.1, abs_path) as
  %    the Request-URI, and the network location of the URI (net_loc) MUST
  %    be transmitted in a Host header field.
  %
  %    For example, a client wishing
  %       to retrieve the resource above directly from the origin server would
  %       create a TCP connection to port 80 of the host "www.w3.org" and send
  %       the lines:
  % GET /pub/WWW/TheProject.html HTTP/1.1
  % Host: www.w3.org
  %
  % followed by the remainder of the Request. Note that the absolute path
  %    cannot be empty; if none is present in the original URI, it MUST be
  %    given as "/" (the server root).
  %
  %
  %
  %      http://ftp.ics.uci.edu/pub/ietf/http/rfc2068.txt
  %
  %      For definitive information on URL syntax and semantics, see RFC 1738
  %         [4] and RFC 1808 [11].
  %
  %
  % The use of IP addresses in URL's SHOULD be avoided whenever possible (see RFC 1900 [24])
  %
  % If the abs_path is not present in the URL, it MUST be given as "/" when used as a Request-URI for a resource (section 5.1.2).
  %
  % subsection http_protokolla (end)

  \subsection{Internet-resurssien tunnisteet (URI, URL, URN ..ja XRI)} % (fold)
  \label{sub:käsitteet_uri_url_ja_urn}

  \verb!URI! (Universal Resource Identifier) on tapa yksilöidä sisältöä internetissä. Sisältö voi olla mitä tahansa: yleisinä esimerkkeinä ovat HTML-sivu, kuvatiedosto tai videostream. Käsitteet \verb!URL! (\emph{Universal Resource Locator}) ja \verb!URN! (\emph{Universal Resource Name}) ovat \verb!URI!:n osajoukkoja (kuva~\ref{fig:uri_url_urn}). Käsitteitä URI ja URL käytetään usein hämmentävästi ristiin~\cite{w3c_uri_clarifications} ja URN ei ole monestikaan webissä relevantti. HTTP-kontekstissa URI tarkoittaa ainoastaan muotoiltua merkkijonoa, joka yksilöi resurssin sen nimen, sijainnin tai muun ominaispiirteen perusteella~\cite{ietf_rfc_http1.1}. Lisäksi on olemassa myös muita URI-tyyppejä -- kuten \verb!XRI! -- joten jokainen webissä esiintyvä URI ei ole URL. XRI:stä lisää OpenID-kappaleessa. (todo viite)

  \verb!URL! on sisällön tietyssä sijainnissa yksilöivä tunniste. Sisältö sijaitsee resurssissa, ja URL on abstrakti tapa resurssin sijainnin määrittämisen~\cite{ietf_rfc_urls}. Tämän tutkielman URL voisi olla esimerkiksi \url{http://www.cs.helsinki.fi/u/repo/gradu/g.pdf}, jossa \verb!http! on skeema, \url{www.cs.helsinki.fi} verkkotunnus ja \url{u/repo/gradu/g.pdf} on url-polku. Siitä, mitkä voisivat olla tähän URL:iin liittyvät resurssit, kerrotaan tarkemmin kappaleessa~\ref{sub:arkkitehtuurityyli_rest}. URL:n yleinen koostumus on~\cite{ietf_rfc_urls}:
  \\ \verb!skeema://käyttäjätunnus:salasana@verkkotunnus:portti/url-polku!

  Tämän tutkielman kannalta oleelliset skeemat ovat \verb!http! ja \verb!https!, joiden puitteissa URL:n käyttäjätunnus, salasana ja portti voidaan jättää URL:sta pois. Portti on http-skeemassa oletusarvoisesti 80~\cite{ietf_rfc_urls} ja https-skeemassa 443~\cite{ietf_rfc_http_tls}. URL:n loppuosa -- url-polku -- koostuu http(s)-skeeman yhteydessä kauttaviivoin (''/'') erotelluista merkkijonoista, jotka yksilöivät URL:n kuvaaman resurssin verkkotunnuksen asiayhteydessä. Ensimmäinen kauttaviiva verkkotunnuksen (tai portin) jälkeen ei kuulu url-polkuun~\cite{ietf_rfc_urls}. URL-käyttäjätunnuksesta lisää kappaleessa \emph{HTTP Basic Auth} (todo viite).


  \verb!URN! on sisällön yksilöivä nimitunniste. URN on tarkoitettu pysyväksi ja sijainninsta riippumattomaksi resurssin tunnisteeksi, jonka tulee olla ''globaalisti ja pysyvästi uniikki riippumatta sitä kuvaavan resurssin olemassaolosta''~\cite{ietf_rfc_uri_syntax}. URN koostuu nimiavaruudesta sekä nimiavaruudessa yksikäsitteisestä merkkijonosta eli nimitunnisteesta: \verb!urn:nimiavaruus:nimitunniste!~\cite{ietf_rfc_urn_syntax}. Esimerkiksi kirjoja yksilöivä ISBN-tunniste voidaan määritellä URN:n avulla. Tällöin ISBN-numero 0-123-45678-9 olisi URN-muodossa \verb!urn:isbn:0-123-45678-9!~\cite{w3c_uri_clarifications}. Web-kontekstissa kuitenkin käsitteet URL ja URI ovat vakiintuneet käytössä eikä käsitettä URN kohtaa web-kehittäjälle relevanteissa asiayhteyksissä (todo miksi siitä sitten pitäisi kertoa gradussa).

  % todo
  Tässä leikitellään idealla, jos URN voisi olla yksilöllinen identiteetin tunnus. Esitellään XRI: OpenID:n yksilölllinen identiteetin tunnus. Vieläkö XRI on hengissä? Ei koskaan yleistynyt, koska liian vapaa. Sen jyräsivät yli kirjautuminen Facebook-tunnuksilla ja Googlen logolla.

  \begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{images/uri_url_urn.jpg}
    \caption{Käsitteet URI, URL ja URN}
    \label{fig:uri_url_urn}
  \end{figure}

  % subsection käsitteet_uri_url_ja_urn (end)


  % TODO / POIS:
  %
  % \subsection{Arkkitehtuurityyli: WS-* ja SOAP} % (fold)
  % \label{sub:arkkitehtuurityyli_ws_}
  %   Web Services (WS-*) on Microsoftin (alkujaan määrittelemä?) kokoelma arkkitehtuurityylejä (todo viite), joiden perusteella voidaan suunnitella web-palvelun arkkitehtuurin eri näkökulmat.
  %
  %   SOAP ja XML.
  % % subsection arkkitehtuurityyli_ws_ (end)


  % TODO / POIS:
  %
  % \subsection{Arkkitehtuurityyli: REST} % (fold)
  % \label{sub:arkkitehtuurityyli_rest}
  %
  % Määrittele resurssi (http rfc, fielding-väitöskirja)
  %
  % URL määrittää resurssin käyttötavan eli skeeman (\emph{scheme}), ja HTTP-protokollan verbi (GET, POST, UPDATE, DELETE) määrittää operaation tyypin.
  %
  % Sessiopohjainen autentikointi ja restful api. Clientin täytyy pitää yllä tilaa (vs. http basic auth).
  % Auktorisointi ja käyttäjän luvan kysyminen: tilan ylläpito välttämätöntä. Kehittäjäresistenssi ''http basic auth helpompi toteuttaa''.



  % subsection arkkitehtuurityyli_rest (end)


  \subsection{Palveluorientoitunut arkkitehtuuri (SOA)} % (fold)
  \label{sub:arkkitehtuurityyli_soa}

  Löyhästi kytketyt palvelut (loosely coupled).
  Mahdollisuus uusien toimintojen lisäämiseen itsenäisinä \emph{palveluina}
  Pitkällä aikavälillä ylläpito ja jatkokehitys helpompaa, koska muutokset vaikuttavat vain palveluun itseensä.
  Palvelut kommunikoivat keskenään rajapintojen kautta, erityisesti yleistynyt on HTTP.
  Rajapinnat määritellään web-kontekstissa joko REST- tai WS-*-arkkitehtuurityylin mukaisesti.
  orkestrointi vs koreografia

  SaaS-kokonaisuus koostuu kokoelmasta palveluja, ja jokainen palvelu koostuu joukosta operaatioita, jotka palvelun asiakas käynnistää (invoke, todo termi).

  Design by Contract: rajapintakutsun esi- ja jälkiehdot.
  % B. Meyer. Applying Design By Contract.Computer, No. 25, Vol. 10, 1992

  % subsection arkkitehtuurityyli_soa (end)


  \subsection{Rajapinnan pääsyoikeuksien varmistaminen} % (fold)
  \label{sub:rajapintakutsun_pääsyoikeudet}

  Auktorisointi ei ole tutkielman fokuksessa. Kerrotaan siitä minimiminimi.

  Erilaisia API-autentikointitapoja on lähes yhtä paljon kuin erilaisia API-toteutuksia. Jokainen oma autentikointitapa vaatii oman autentikointitoteutuksen. Sitä vastoin http basicille, oauthille, samlille ym on jo runsas valmis kirjastotuki.  Älä kehitä omaa autentikointitapaa.

  api-keyt non-sensitive datalle. vrt älä laita session identifier urliin (security). Google maps esimerkki api-keystä: käyttäjien klikkauksia voidaan seurata ja palvelulla voi olla oma käyttömääräkiintiö karttoihin, mutta api-keyllä haettu karttadata ei ole salaista. Eri asia palvelin-palvelin yhteyksissä, joissa api-key ei näy käyttäjälle.

  restapi security vs soap-api ja WS-Security

  % subsection rajapintakutsun_pääsyoikeudet (end)

  % \subsection{Kommunikaatiotavat: front-channel ja back-channel} % (fold)
  % \label{sub:kommunikaatiotavat_front_channel_ja_back_channel}
  %
  % Front Channel yksinkertainen toteutus kun HTTP-binding. Tällöin ainoastaan user-agent on viestinvälittäjä, mikä mahdollistaa yksinkertaisen protocol flown.
  %
  % Korkeampaa turvallisuustasoa tai tiukempaa yksityisyyttä tavoiteltaessa kokonaisen viestin sijasta user-agent voi välittää pelkän \emph{viitteen} tietoon. Tällöin user-agentin viitteeseen liitetty varsinainen tieto (esim. SAML-assertio, artifakti) välitetään palvelin-palvelin-yhteydellä back-channelin kautta kyseisen user-agentin antaman viitteen perustella.
  %
  % SAML ja back-channel määritellään SOAP-viestinvälityksenä (SAML over SOAP over HTTP).
  % (viite %http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language)
  %
  % % subsection kommunikaatiotavat_front_channel_ja_back_channel (end)


% section autentikoituminen_ja_web (end)


  \subsection{Selain-, sisältö- ja applikaatiokonteksti} % (fold)
  \label{sub:selainkonteksti_vs_applikaatiokonteksti}

  Tähän johdantokappale, jossa kerrotaan että käyttäjän täytyy tietää, että hän syöttää salasanansa oikeaan palveluun. Käyttäjäagentin on oltava siis luotettu. Käyttäjä tietää että hän autentikoituu esim Facebook-tunnuksilla. Käyttäjälle pitää näyttää facebookin sivu luotetussa kontekstissa. Erittäin oleellista kun ulkoinen identiteetintarjoaja ja random-identiteetinkuluttajia (Jenni Vartiainen -app kysyy facebook-salasanaa suoraan.)

  Selainkontekstissa käyttäjä voi luottaa siihen, mitä osoiterivillä lukee, kun työasema oletetaan turvalliseksi (ei troijalaisia tms). Selaimen oman ulkonäön ja turvallisuustoimien väärentäminen erittäin työlästä. Kuvassa~\ref{fig:facebook_reauth_ab} selaimen URL-osoiterivillä oleva, turvallista HTTPS-yhteyttä kuvaava lukko (A) ilmaisee, että yhteys selaimen ja palvelimen välillä on suojattu. Selainkontekstissa käyttäjän on mahdollista varmistua siitä, että oikea sivusto kysyy salasanaa. Selaimen osoiterivillä täytyy olla palvelua vastaava URL-osoite (B). Pelkkä lukko ei vielä takaa turvallisuutta, koska se ilmaisee ainoastaan selaimen ja palvelun välisen yhteyden olevan turvallinen. Käyttäjän itsensä täytyy voida varmistua siitä, että yhteys on \emph{oikeaan palveluun}. Käyttäjää on mahdollista jekuttaa selainkontekstissa lukon kuvalla, jos osoiterivillä esim. ''faceboook.com''.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/Facebook_reauth_ab.jpg}
    \caption{Turvallisuusilmoitukset selainkontekstissa}
    \label{fig:facebook_reauth_ab}
  \end{figure}

  Käyttäjä ei voi luottaa selaimen sisältökontekstin turvallisuusilmoituksiin. Käyttäjä saattaa tulla huijatuksi, jos hän ei kiinnitä huomiota selaimen turvallisuusilmoituksiin tai niiden puutteeseen~\cite{why_phishing_works_06}. Modernit selaimet näyttävät useita erilaisia ilmaisimia turvalliselle HTTPS-yhteydelle, mutta suojaamattomalle yhteydelle ei ole vakiintunutta ilmaisinta. Monet käyttäjät eivät kiinnitä lainkaan huomiota ilmaisimiin, ja monesti käyttäjä on tyytyväinen sivun sisältökontekstissa olevaan turvallisuusilmoitukseen. Kuvassa~\ref{fig:trust_context_html} HTML-sisältösivu itse ilmoittaa olevansa turvallinen (D) ja näyttää sisältöosassa lukon kuvan. Ilmoitus on hyväntahtoinen, mutta tässä tapauksessa käyttäjä voi luottaa ainoastaan siihen, että selaimen osoiterivillä oleva palvelu (C) on luotettava. Sisältökontekstissa voi kuitenkin olla käyttäjän kannalta hyödyllistä ilmoittaa, jos sisäänkirjautumisyhteys \emph{ei ole} turvallinen (kuva~\ref{fig:trust_context_html_unsecure}): tällöin käyttäjä voi halutessaan olla syöttämättä salasanaansa esimerkiksi kahvilan avoimessa WLAN-verkossa.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/trust_context_html.jpg}
    \caption{Turvallisuusilmoituksia selain- (C) ja sisältökontekstissa (D)}
    \label{fig:trust_context_html}
  \end{figure}


  \begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/trust_context_html_unsecure.png}
    \caption{Turvattomuusilmoitus sisältökontekstissa}
    \label{fig:trust_context_html_unsecure}
  \end{figure}


  Applikaatiokonteksti on relevantti erityisesti mobiilikäyttöjärjestelmissä, joissa yleistyneet sosiaalisen median toiminnot luovat tarpeen luotettavalle tavalle autentikoitua. Mobiilikäyttöjärjestelmistä esimerkiksi Android ei rajoita sovellusten asentamista, eikä myöskään Android Marketista asennettujen ohjelmistojen turvallisuudesta ole takeita (todo etsi viite tietomurtojuttuun). Siksi käyttäjän salasanan kirjoittaminen on syytä tehdä varmasti luotettavassa applikaatiossa kuten mobiilijärjestelmän omassa web-selaimessa tai kohteena olevan palvelun virallisessa applikaatiossa.

  Esimerkiksi Facebookin SDK pyrkii ensisijaisesti avaamaan virallisen Facebook-applikaation, kun kolmannen osapuolen applikaatio pyytää käyttäjää autentikoitumaan Facebook-tunnuksillaan tai pyytää käyttöoikeutta hänen Facebook-tietoihinsa (kuva~\ref{fig:trust_context_mobile_fb}). Jos virallista Facebook-applikaatiota ei ole asennettu, SDK:n toissijainen menetelmä on avata autentikointitapahtuma järjestelmätason web-selaimessa (kuva~\ref{fig:trust_context_mobile_unknown_secure}), jolloin käyttäjä voi varmistua palvelun autenttisuudesta selaimen osoiterivin perusteella. Vasta viimeisenä vaihtoehtona, jos mobiililaite ei tue useamman sovelluksen rinnakkaista suorittamista (\emph{multi-tasking}), Facebook SDK suorittaa autentikoinnin applikaatiokontekstissa (viite \verb=https://developers.facebook.com/docs/mobile/ios/build/#implementsso=).

  \begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/trust_context_mobile_fb.png}
    \caption{Käyttöoikeuspyyntö mobiilikontekstissa. Käyttäjä on autentikoitunut Facebook-applikaation kontekstissa jo aiemmin, joten sisäänkirjautuminen on käytettävissä kolmannen osapuolen sovellukselle ilman salasanan syöttämistä.}
    \label{fig:trust_context_mobile_fb}
  \end{figure}

  \begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/trust_context_mobile_unknown_secure.png}
    \caption{Autentikointi mobiilissa selainkontekstissa. Selaimen yläpalkissa ei ole turvallista yhteyttä esittävää lukon kuvaa, joten käyttäjä ei voi varmistua näytetyn sivuston autenttisuudesta.}
    \label{fig:trust_context_mobile_unknown_secure}
  \end{figure}

  % "Salasanaa ei saa kysyä mobiiliapplikaation sisällä:" http://fireeagle.yahoo.net/developer/documentation/oauth_best_practice

  Jos käyttäjä valmiiksi sisäänkirjautunut OAuth-palveluun (esim. Facebook), sisältöcontextissa voidaan näyttää authorization overlay (todo selitä termi, vrt popup ja piirrä kuva), jossa käyttäjä joko sallii tai kieltää tietojensa jakamisen. Overlay-sivu tarjoillaan suoraan Facebookista, jolloin facebookin cookie on valmiiksi käytettävissä jolloin facebookin ei tarvitse kysyä salasanaa. Pahantahtoinen applikaatio ei saavuta mitään tämän sivun spooffaamamisella.

  Tilanne on eri, jos OAuth-sisäänkirjautumista ei ole vielä tapahtunut, jolloin käyttäjän täytyy syöttää salasanansa. Tällöin salasanaa ei voida kysyä app trust -kontekstissa, koska mikä tahansa palvelu pystyy tekemään facebook-loginsivun näköisen sivun. Myöskään mikään selaimen anti-phishing toiminto ei laukea, koska kaikki tapahtuu luvallisesti applikaation omassa trust kontekstissa. Delegoidun autentikoinnin perusperiaatteena on päästä eroon salasanan syöttämisestä kolmannen osapuolen sivustolle, mutta OAuth-salasanan kysyminen app trust kontekstissa antaa käyttäjälle mielikuvan, että salasana syötetään kolmannen osapuolen palveluun. Ideologian mukainen tapa on avata sisäänkirjautuminen selainkontekstissa, jolloin selaimen phishing-turvallisuusominaisuudet estävät käyttäjän syöttämien tietojen kaappaamisen kolmannen osapuolen palveluun ja (tärkeintä) käyttäjä näkee siirtymän toiseen palveluun (osoiterivillä facebook.com). (todo: selitä ylempänä mikä on DOM ja että miksi OAuth autentikointi pitää tehdä eri DOMissa kuin missä 3-osapuolen palvelu on.)

  % subsection selainkonteksti_vs_applikaatiokonteksti (end)

% section 2-luku (end)

\section{Sisäänkirjautuminen web-palveluissa} % (fold)
\label{sec:autentikoituminen_ja_web}

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/usnavy_authentication.jpg}
    \caption{Yhdysvaltain ilmasotajoukkojen toisen maailmansodan ajan koulutusmateriaalia~\cite{usnavy_authentication}}
    \label{fig:autentikointi_suojaa_viholliselta}
  \end{figure}

  Tässä selitetään autentikointi ja auktorisointi. Tutkimuksen fokuksena on autentikointi.

  % autentikoinnista lampson ja id_in_federation_systems_2005 kpl 2.1

  Web-palvelun asiakas (todo termi) autentikoituu todistamalla, että hänellä on hallussaan ja hallinnassaan \emph{poletti} (\emph{token}). Poletti on rekisteröity ennakkoon web-palvelun käyttämälle identiteetintarjoajalle, ja sitä vastaan web-palvelu (identiteetin kuluttaja) voi varmistua poletin \emph{kantajan} (\emph{bearer}). Poletin kantajana toimivaa asiakasta kutsutaan \emph{väittäjäksi} (\emph{claimant}), koska asiakkaan identiteetti perustuu yksipuoliseen väittämään, kunnes autentikointitapahtuma on suoritettu ja väittäjä todistanut identiteettinsä. Polettiin liittyy salaisuus (\emph{secret}), jolla väittäjä osoittaa, että hän on poletin rekisteröimisen yhteydessä palveluun määritetty toimija (\emph{subscriber})~\cite{NIST_SP800-63-1}. Salaisuus perustuu joko julkiseen avainpariin (asymmetrisiin avaimiin, \emph{asymmetric keys}) tai \emph{jaettuun salaisuuteen} (\emph{shared secret}).

  \emph{Julkinen avain} ja sitä vastaava \emph{yksityinen avain} muodostavat \emph{julkisen avainparin} (\emph{public key pair})~\cite{NIST_SP800-63-1}.
  Polettiin on varastoitu joko yksityinen avain kokonaisuudessaan~\cite{NIST_SP800-63-1} tai viite siihen (todo etsi esimerkki).
  Identiteetintarjoaja tallettaa poletin rekisteröimisen yhteydessä avainparin julkisen avaimen itselleen. Tyypillinen menetelmä on varastoida julkinen avain \emph{sertifikaattiin} ja tallettaa se identiteetintarjoajalle. Tällöin identiteetintarjoaja voi soveltaa julkiseen avainpariin perustuvaa autentikointiprotokollaa ja esittää väittäjälle haasteen, jonka vastaus edellyttää avainparin yksityisen komponentin tuntemista -- eli pääsyä polettiin.

  \emph{Jaettu salaisuus} voi olla joko \emph{symmetrinen avain} (\emph{symmetric key}) tai salasana~\cite{NIST_SP800-63-1}. Näitä kahta voidaan käyttää samankaltaisissa autentikointiprotokollissa, mutta merkittävnä erona on niiden näkyminen käyttäjälle. Symmetrinen avain on tyypillisesti kytketty johnonkin käyttäjän hallinnoimaan laitteeseen tai ohjelmistoon, mutta salasana täytyy muistaa ulkoa. Muistettavuuden vuoksi salasanat ovat kryptografista avainta pituudeltaan lyhyempiä merkkijonoja, joten salasanalla on vähemmän erilaisia mahdollisia arvoja kuin avaimella. Symmetristä avainta ja salasanaa käytetätään sen vuoksi eri käyttötarkoituksiin.

  todo kuva; miksi puhutaan poletista. Hashed passwords --> palveluntarjoaja ei talleta salasanaa vaan hashin, eli palveluntarjoajallakin on poletti.

  % Paradigma: Web, SaaS, HTTP, user-agent/web-browser.
  % Mikä on web-palvelu?
  % Mikä on sisäinen palvelu?
  %
  % Selitä auki tutkimuksen fokus:
  % Miksei active directory, kerberos, cas, ldap ole relevantti?
  % Voiko niitä kuitenkin hyödyntää (esim. SaaS-palvelu - Google Apps - Active Directory)
  % Miksi HTTP suosituin protokolla?
  %
  % Identiteetti: Kuka teki pyynnön?
  % Autentikointi: Onko tekijä todella se, joka hän väittää olevansa?
  % Auktorisointi: Onko tekijällä valtuudet tehdä se, mitä hän yrittää tehdä?
  %
  % Identity Management and Trust Services: Foundations for Cloud Computing
  % http://www.educause.edu/EDUCAUSE+Review/EDUCAUSEReviewMagazineVolume44/IdentityManagementandTrustServ/178410

  %%%%%%%%%%%%%%%%%%
  % ''Assertions are statements from a Verifier to an RP that contain information about a
  % Subscriber. Assertions are used when the RP and the Verifier are not collocated (i.e., they
  % are connected through a shared network). The RP uses the information in the assertion to
  % identify the Claimant and make authorization decisions about his or her access to
  % resources controlled by the RP. An assertion may include identification and
  % authentication statements regarding the Subscriber, and may additionally include attribute
  % statements that further characterize the Subscriber and support the authorization decision
  % at the RP.''
  % %
  % ''There are two basic models for assertion-based authentication. After successful
  % authentication with the Verifier, the Subscriber is issued an assertion or an assertion
  % reference, which the Subscriber uses to authenticate to the RP.''
  % %
  % ''an assertion contains a set of claims or statements about an
  % authenticated Subscriber. Based on the statements contained within it, an authentication
  % assertion will fall into one of two categories (and either category can be used in both
  % direct and indirect models): Holder-of-Key Assertions ja Bearer Assertions. (sivu 83.)''
  % %
  % Lisäksi Proxy-model, jossa käyttäjä <--> verifier/portal <--> relying party.
  % %
  % % ''Three types of assertion technologies will be discussed within this section: Web browser
  % %   cookies, SAML (Security Assertion Markup Language) assertions, and Kerberos tickets''
  % %
  % ''Cookies are effective as assertions for Internet single-sign-on where the RP and Verifier
  % are part of the same Internet domain, and when the cookie contains authentication status
  % for that domain. They are not usable in scenarios where the RP and the Verifier are part
  % of disparate domains.''
  % %
  % Cookies are also often used by the Claimant to re-authenticate to a server. This may be
  % considered to be a use of assertion technology. In this case, the server acts as a Verifier
  % when it sets the cookie in the Subscriber’s browser, and as an RP when it requests the
  % cookie from a Claimant who wishes to re-authenticate to it. Often, the cookie contains a
  % random number, and the assertion data that it represents does not leave the server.
  % % Kpl 9: Assertions
  % % NIST-Special-Publication-800-63-1-E-Authentication-Guidelines.pdf
  % % todo tähän myös Figure 4 ja Figure 5 samasta guidelinesta!


  \subsection{Haaste--vastine-autentikaatio} % (fold)
  \label{sub:haaste_vastine_autentikaatio}

  \emph{Haaste--vastine-autentikoinniksi} (\emph{challenge-response authentication}) kutsutaan autentikointitapaa, jossa toinen osapuoli esittää kysymyksen (haasteen), johon toisen osapuolen on tarjottava kelvollinen vastaus (vastine) \cite{NIST_SP800-63-1}. Haaste voi olla esimerkiksi satunnaisluku, jonka haastaja lähettää vastaajalle ja johon vastaaja yhdistää jonkin ennalta jaetun salaisuuden. Yhdistäminen voidaan tehdä esimerkiksi laskemalla tiiviste haasteesta ja salaisuudesta, joka lähetetään takaisin haastajalle. Koska haastaja tuntee jaetun salaisuuden, hän pystyy laskemaan oman versionsa tiivisteestä. Haaste voidaan hyväksyä, jos sekä haastajan itse laskema että vastaanottama tiiviste ovat identtiset \cite{NIST_SP800-63-1}.

  Autentikoituminen käyttäjätunnuksella ja salasanalla on yksi haaste--vastine-autentikoinnin sovellus. Salasana-autentikoinnissa toinen osapuoli kysyy haasteena käyttäjätunnusta ja salasanaa, ja toisen osapuolen on tarjottava siihen vastineena täsmälleen oikeanlaiset merkkijonot.

  1990-luvun tietokonepeleissä oli usein kopionestosuojauksia, jotka häiritsivät tai estivät pelaamisen ellei käyttäjä tarjonnut oikeaa vastausta pelin esittämään haasteeseen. Yleensä haasteena oli jokin kysymys, johon löytyi vastaus pelin laillisen kopion mukana toimitetussa paperisessa ohjekirjassa. Motiivina oli tehdä laittoman pelikopion levittäminen pelkkien tiedostojen kopioimista vaivalloisemmaksi. Tuohon aikaan laajan dokumentin kopioiminen oli varsin työlästä, eivätkä kopiokoneet ja skannerit eivät olleet yleisiä. Tämän tutkielman kirjoittaja vietti ala-asteikäisenä joskus iltaa kopioimalla kynällä ja paperilla tällaisia koodikirjoja itselleen.

  Haasteeseen voi olla myös julkisesti tunnettu vastine. Spämmibottien torjumiseksi kehitetty CAPTCHA-testi (\emph{Completely Automated Public Turing test to tell Computers and Humans Apart}) kysyy kysymyksen (esittää haasteen), johon ihmisen on helppo vastata (tarjota vastine), mutta johon tietokone ei pysty luotettavasti tuottamaan oikeaa vastausta. CAPTCHA-haaste voi olla esimerkiksi yksinkertainen matemaattinen laskutoimitus, bittikarttakuvaan upotettu ihmissilmällä erottuva sana tai yksiselitteinen suomenkielinen kysymys, johon on yksiselitteinen ja yleisesti tunnettu vastaus.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/Facebook_captcha_filled.jpg}
    \caption{Esimerkki CAPTCHA:n käytöstä Facebookissa}
    \label{fig:captcha_facebook}
  \end{figure}

  % subsection haaste_vastine_autentikaatio (end)


  \subsection{Salasanat ovat vallitseva käytäntö} % (fold)
  \label{sub:salasanat}
  Salasanojen vahvuus, ihmisten tapa käyttää salasanoja, salasanat kustannustehokas ratkaisu.
  Ihmiset eivät muista salasanoja. Sama salasana monessa paikassa. Ongelma.

  Yhdistä tähän kappaleet Salasanat ja Salasanat ovat vallitseva käytäntö

  Salasana on jaetun salaisuuden toteutus, ja salasanat ovat yleisin tapa tunnistautua palveluihin internetissä \cite{study_of_passwords_07, passpet_06, password_management_strategies_06, pwdhash_extension_05}.
  Salasanan turvallisuus riippuu salasanan uniikkiuden (ei käytössä muissa palveluissa) lisäksi siitä, kuinka työläs se on arvata joko väkisin tai hyödyntäen sosiaalista tiedonkeruuta. Koska pitkät ja vaikeat salasanat ovat myös vaikeampia muistaa kuin lyhyet ja helpot, loppukäyttäjät päätyvät usein käyttämään samaa salasanaa monessa eri palvelussa \cite{study_of_passwords_07}. Turvattomin vaihtoehto on, että käyttäjällä on lyhyt ja helppo salasana kaikissa käyttämissänsä palveluissa.

  Saman salasanan käyttäminen monessa palvelussa on riski. Jos käyttäjän salasana päätyy vääriin käsiin yhden palvelun kautta, vaarantuvat samalla kaikki muut palvelut, joissa käyttäjällä on sama salasana. Esimerkiksi joulukuussa 2010 Gawker.com-juorupalvelun tietomurron yhteydessä 1,3 miljoonaa salasanaa päätyi kerralla vääriin käsiin, kun kaikki kerätyt salasanat vuodettiin julkisiksi \cite{bbc_gawker_12_2010, forbes_gawker_12_2010}. Juorujen kommentoimiseksi luotujen käyttäjätunnusten vuotaminen oli ongelmallista, koska moni käyttäjä käytti samaa salasanaa myös muissa palvelussa. Tämän seurauksena esimerkiksi Twitterissä havaittiin käyttäjätunnuksia valloittanut spämmiaalto. Lisäksi mielenkiintoista oli, että vuodetuista 188.279 salasanasta lähes 2.000 kappaletta oli ''password'' ja yli 3.000 oli  ''123456''~\cite{forbes_gawker_12_2010}. Paljastuneista salasanoista yleisimmät 20 on esitetty kuvassa~\ref{fig:gawker_top20_passwords}.

  % salasanatriviaa: http://www.lukew.com/ff/entry.asp?1487



  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/gawker_top20_passwords.jpg}
    \caption{Gawker-tietomurron yhteydessä paljastuneet 20 yleisintä salasanaa~\cite{wsj_gawker_12_2010}.}
    \label{fig:gawker_top20_passwords}
  \end{figure}




  % Rational rejection of security advice by users
  % http://research.microsoft.com/en-us/um/people/cormac/papers/2009/SoLongAndNoThanks.pdf

  Turvallinen salasana edellyttää hankalaa arvattavuutta ja uniikkiutta. Florêncio ja Herley \cite{study_of_passwords_07} tutkivat ihmisten salasanatapoja kolmen kuukauden ajan 500.000 käyttäjän aineistolla. He havaitsivat, että keskimääräisellä käyttäjällä on 6,5 salasanaa, joista jokainen on jaettu 3,9 eri palvelun kesken. Jokaisella käyttäjällä on keskimäärin 25 salasanaa vaativaa käyttäjätunnusta ja päivittäin kirjoitetaan keskimäärin 8 salasanaa. Käyttäjän ongelmana on siksi usein muistaa, mikä kuudesta eri salasanasta sopii juuri tiettyyn palveluun. Moni käyttäjä kokeilee palveluun vuorotellen kaikkia salasanojansa, kunnes oikea löytyy \cite{study_of_passwords_07}. Tämä on väärinkäytösten osalta ongelmallista, jos palvelu tallettaa kokeillut salasanat luettavassa muodossa jonnekin.

  % subsection salasanat (end)

  \subsection{Kaksi- ja monivaiheinen autentikointi} % (fold)
  \label{sub:kaksivaiheinen_autentikointi}

  Perus-haaste-vastine-autentikoinnissa jos tietoliikenneyhteys (tai muu kommunikaatiokanava) ei ole turvallinen tai vastine muilla tavoin päätyy vääriin käsiin, salakuuntelija (eavesdropper) voi oppia jokaisen esitetyn haasteen vastineen, ja (väärin)käyttää vastinetta itse.
  Tällaisia mitm, troijalaiset, social engineering, olanylikatselu jne.

  Kaksivaiheisuus tuo autentikointiin lisävaiheen. Haaste--vastine-autentikoinnissa käyttäjän on annettava esitettyyn haasteeseen kelvollinen vastine eli osoitettava toiselle osapuolelle että hän \emph{tietää} jotain. Kaksivaiheisessa autentikoinnissa käyttäjän on lisäksi osoitettava, että hänellä \emph{on hallussaan} jotain \cite{NIST_SP800-63-1, google_2step_2010}. Jälkimmäinen tekijä voidaan muodostaa esimerkiksi lähttämällä käyttäjän puhelinnumeroon vahvistuskoodin sisältävä tekstiviesti tai kysymällä merkkijonoa, jonka jokin ulkoinen laite tuottaa. Autentikoinnin suorittamiseksi käyttäjän on tietyn ajan sisällä esitettävä kelvollinen vastine molempiin haasteisiin.

  Internet-palveluissa yleisin kaksivaiheisuuden toteutustapa on käyttäjän matkapuhelimen hyödyntäminen. Tekstiviestillä käyttäjä pystyy osoittamaan pitävänsä hallussa ennalta tunnettua puhelinnumeroa (hyvänä puolena toimivuus kaikissa tekstareita tukevissa puhelimissa). Toinen yleinen keino on \emph{Google Authenticator} -älypuhelinsovelluksen hyödyntäminen. Google Authenticator -mobiilisovellus tarjoaa rajoitetun ajan voimassa olevan numerosarjan, jota autentikoiva palvelin kysyy onnistuneen salasana-autentikoinnin jälkeen. Älypuhelinsovelluksen hyvänä puolena on riippumattomuus puhelinverkkoyhteydestä, mutta toimiakseen sovellus vaatii tietynlaisen puhelinmallin. Google Authenticator -projektin taustajärjestelmä (\emph{backend}) sekä iOS, Android ja Blackberry -mobiilisovellukset on julkistettu avoimena lähdekoodina (todo lähdeviite http://code.google.com/p/google-authenticator/), minkä ansiosta sillä on mahdollista toteuttaa autentikoinnin kaksivaiheisuus myös Googlesta täysin riippumattomiin palveluihin.

  Internet-mittakaavassa ulkoisen laitteen edellyttäminen hankaloittaa autentikointitavan laajaa käyttöönottoa. Ulkoisista laitteista matkapuhelin on suosittu juuri yleistyneisyytensä vuoksi. On kuitenkin olemassa myös muita ulkoisia laitteita, jotka tarjoavat mahdollisuuden kaksivaiheistaa autentikointi -- näitä käytetään usein yritysverkoissa tai muissa keskitetysti hallituissa verkkoympäristöissä. Osa laitteista markkinoi itseänsä myös salasanan korvaajina ja jotkut palvelut kuten verkkopankit jakavat etukäteen käyttäjilleen listan kertakäyttöisistä salasanoista. Tällöin kyseessä on kuitenkin yksivaiheinen haaste--vastine-autentikointi ellei laitteen tai kertakäyttösalasanalistan lisäksi vaadita mitään muuta tunnistetta.

  Kaksivaiheinen autentikointi on monivaiheisen autentikoinnin (\emph{multifactor authentication}) toteutus (todo termi, erikoistus?).
  Vaiheiden \emph{jotain minkä tiedot} ja \emph{jotain minkä omistat} lisäksi voidaan vaatia \emph{jotain mitä olet} -- tällöin kyse on kolmivaiheisesta autentikoinnista. Vaiheeksi \emph{jotain mitä olet} sopii esimerkiksi sormenjälki, iiriksen skannaaminen tai muu biometrinen tunniste. Monivaiheinen autentikointi tarkoittaa vähintään kahden edellä mainitun vaiheen käyttöä asiakkaan (todo termi, \emph{claimant}) tunnistamiseksi \cite{NIST_SP800-63-1}. Monivaiheisen autentikoinnin toteutus on yleisesti käsitetty vahvemmaksi kuin vain yhtä vaihtetta käyttävä: kolmen vaiheen autentikointi on vahvempi kuin kuin kahta vaihteta käyttävä, ja kahden autentikointivaiheen kokonaisuus on vahvempi kuin yhden vaiheen vaiheen toteutus \cite{NIST_SP800-63-1}. Myös karttapaikannustietoa tai laitteen yksilöivää tunnistekoodia voidaan käyttää autentikointiprosessin tukena, mutta ne eivät kuitenkaan ole autentikointitapoja (\emph{authentication factors}) \cite{NIST_SP800-63-1}.

  Kokonaisturvallisuutta lisäävästä vaikutuksestaan huolimatta monivaiheinen autentikointi ei itsessään ratkaise \emph{man-in-the-middle}-ongelmaa tai suojaa trojalaisilta \cite{schneier_2factor_2005}. Jos kolmas osapuoli pääsee tietoliikenneyhteyden väliin, hän voi välittää kaikki käyttäjän viestit eteenpäin. Man-in-the-Middle ei näe haastetta, jonka palveluntarjaoja lähettää kaksivaiheisessa autentikoinnissa esimerkiksi käyttäjän matkapuhelimeen. Hän kuitenkin näkee kaapatun tietoliikenneyhteyden kautta käyttäjän haasteeseen tarjoaman vastineen ja pystyy välittämään sen eteenpäin palveluntarjoajalle. Vaikka tiedonsiirtokanava olisi turvallinen, käyttäjän huolimattomuuden, päätelaitteessa olevan troijalaisen tai vakoiluohjelmiston on edelleen mahdollista aiheuttaa MITM-turvallisuusongelma~\cite{schneier_2factor_2012} (todo viite security ignorance). Monivaiheisuus lisää kuitenkin hyökkäyksen vaatimaa työläyttä yksivaiheiseen autentikointiin verrattuna, muun muassa koska hyökkäys täytyy kohdistaa tarkemmin tiettyä palveluntarjoajaa vastaan.


  % Esimerkkejä laitteista ovat YubiKey (http://www.yubico.com/yubikey, hyvänä puolena edullinen \$25 hinta), RSA SecurID (http://www.rsa.com/node.aspx?id=1156, huono julkisuus SecurID tietomurto 03/2011)
  % Tectia Mobile ID: Kun käyttäjä kirjautuu palveluun, kännykkään lähetetään (flash-)tekstiviestinä viisinumeroinen koodi, joka pitää syöttää palveluun normaalin salasanan lisäksi.
  % Amazon AWS Multi Factor http://aws.amazon.com/mfa/
  % RSA Murto tapahtui Phishingillä: http://blogs.rsa.com/rivner/anatomy-of-an-attack/

  % TODO: lähdeviite
  % http://support.google.com/accounts/bin/answer.py?hl=en&answer=1066447
  % http://www.mnxsolutions.com/security/two-factor-ssh-with-google-authenticator.html

  % subsection kaksivaiheinen_autentikointi (end)


  \subsection{HTTP-yhteyden suojaaminen ja sertifikaatit webissä} % (fold)
  \label{sub:sertifikaatit_webissä}
  Julkisen avaimen infrastruktuutri.
  Diffie-Hellman.
  HTTP-yhteyden suojaus SSL/TLS-tekniikalla, HTTPS.
  % Client-sertifikaatit. Ei vielä yleistynyt. Silti sama cert monessa eri palvelussa. Revoke hankalaa. OpenID+cert olis hyvä.

  Julkisen avaimen infrastruktuurin mukaiset sertifikaatit ovat yleinen tapa autentikoida palveluntarjoaja webissä~\cite{id_in_federation_systems_2005}. Kaupalliset palveluntarjoajat kuten Thwate ja Verisign toimivat luotettuna kolmantena osapuolena eli sertifikaattiauktoriteettina (\emph{CA, certificate authority}), joiden oma juurivarmenne (\emph{root certificate}) on käyttäjäagentin (selaimen) ennalta tuntemien ja luotettavaksi merkittyjen sertifikaattien listalla. Sertifikaattiauktoriteetti todentaa juurisertifikaattinsa luottamusketjun avulla, että sen jollekin yritykselle myöntämä julkinen varmenne kuuluu sitä esittävälle web-palvelulle. Web-kontekstissa sertifikaatti kytketään URL:n verkko-osoitteeseen, jonka täytyy täsmätä sertifikaattiin kytketyn nimitiedon kanssa.

  Julkisen avaimen infrastruktuuri on laajasti käytössä palvelinpuolella, mutta salasanaan verrattuna se on liian monimutkainen loppukäyttäjille. Monimutkaisuutensa vuoksi sertifikaatteja käytetään monin virheellisin tavoin myös palveluntarjoajan päässä~\cite{eff_ssliverse}. Sertifikaatit eivät ole yleistyneet loppukäyttäjän autentikointitapana, vaikka kaksisuuntainen TLS-suojaus mahdollistaisi sertifikaatin käyttämisen varmenteena HTTPS-yhteyden molemmissa päätepisteissä~\cite{henry_story_foaf_ssl, webid_home}.

  Yhteyden suojaus (https) välttämätöntä jotta turvallista. Erityisesti DNS spoofing ja man-in-the-middle mahdollisia suojaamattomassa yhteydessä.
  HTTPS:n käyttäminen suojaa todella monelta tietoturvauhkalta;
  HTTPS aina kaikelle sensitiiviselle. API-avaimen, OAuth-tokenin tai muun pystyy kaappaamaan verkkoliikenteestä ilman HTTPS:ää.  Suojauksen implementointi on transport layerin tehtävä. Transport layerin on oltava turvallinen!


  % subsection sertifikaatit_webissä (end)

  % subsection sessiopohjainen_autentikointi (end)


  \subsection{HTTP Basic Auth ja HTTP Digest Auth} % (fold)
  \label{sub:http_basic_auth_ja_http_digest_auth}
  Tässä kerrotaan mikä on basic auth (\verb!http://tunnus:salasana@osoite.fi/uri!) ja mikä on http digest auth (haaste-vastine http headereissa).

  % It is clearly unwise to use a URL that contains a password which is
  % intended to be secret. In particular, the use of a password within
  % the 'userinfo' component of a URL is strongly disrecommended except
  % in those rare cases where the 'password' parameter is intended to be
  % public.
  % rfc 2396


  % subsection http_basic_auth_ja_http_digest_auth (end)


  % \subsection{Uhat turvalliselle autentikoitumiselle (ohjelmistokehittäjän näkökulmasta)} % (fold)
  % \label{sec:uhat_turvalliselle_autentikoitumiselle}
  %
  %   OAuth security token -tyypit:
  %   - Bearer vaatiin aina HTTPS:n.
  %   - Mac (vrt. token scheme oauth 1.0), turvallinen vaikkei suojattu yhteys. Vaatii keyn ja secretin, ja käyttää hashmacia kryptaamaan osan requestista. Seurauksena pyyntö valid ainoastaan jos molemmilla osapuolilla samat avaimet, kolmannen osapuolen ei ole mahdollista uudelleenluoda alkuperäistä requestia ilman validia salasanaa.
  %   - SAML Mahdollistaa SAML-assertioiden käytön. Mahdollistaa olemassaolevan SAML-toteutuksen hyödytämisen OAuthissa. (todo esimerkki milloin hyödyllinen, esim. sisäverkon active directory + julkinen web-palvelu)
  %
  %   Mitkä on Pihvin kannalta oleellisimmat?
  %   OAuth draftin threat model -dokumentti.
  %
  %   Haavoittuvuudet, jotka huomioitava, vaikka yhteys olisi suojattu HTTPS:llä:
  %   CSRF: OAuth draft kpl 10.12.: ''The client MUST implement CSRF protection for its redirection URI.''
  %   Clickjacking: Oauth draft kpl 10.13.
  %      ''To prevent this form of attack, native applications SHOULD use
  %      external browsers instead of embedding browsers in an iframe when
  %      requesting end-user authorization.''
  %   Code Injection ja Input Validation (kpl 10.14.)
  %   Open Redirectors (kpl 10.15.)
  %
  %   Phishing ja selaimen omat vastatoimet.
  %
  % % section uhat_turvalliselle_autentikoitumiselle (end)





\section{Yhteiskäyttöiset kertakirjautumisen autentikointistandardit} % (fold)
\label{sec:Kertakirjautumisstandardit}
  \begin{quote}
      ''The fool saith, 'Put not all thy eggs in one basket' ...
      but the wise man saith, 'Put all your eggs in one basket, and watch that basket!' ''
      \\--- Mark Twain \cite{twain_eggs_1894}
  \end{quote}

  Historia, miksi keskitetty kertakirjautumissysteemi on tarpeellinen.

  Tarve perustuu siihen, että keksiä ei voi jakaa domainien kesken. Kerrotaan, miten keksejä käytetään autentikoinnissa. Keksiin talletetaan sessiotieto yhden palvelun tai tieton domainin kontekstissa. Selaimen tietoturvamalli estää keksien jakamisen domainien kesken. On mahdollista
jakaa *.domain.com. Keksin käyttäminen integraatiopisteenä ei ole suositeltavaa. Vertaa SOA:
ennemmin rajapinta palvelujen välille, jolloin jokainen palvelu voi itse ylläpitää omaa tilaansa.
(Sama kuin tietokannan käyttäminen integraatiopisteenä: muutokset yhteen palveluun vaikuttavat
myös muihin palveluihin.) Client-server, server-server. Application-Useragent-Server.


  Tässä kerrotaan, miksi AD, LDAP, Kerberos ja CAS eivät ole tutkielman kannalta relevantteja. Syynä se, että ne eivät ole internet-skaalan standardeja. Niitä voidaan kuitenkin käyttää palvelun sisäisessä toteutuksessa (ks johdannon yleiskuva). Esimerkiksi Kerberos edellyttää että kaikki clientit ovat samassa kellonajassa kuin server, koska timestamp leivotaan kerberos-tiketin sisään (miten eroaa client-server-server jutussa). Rajapintana jokin muu kuin http. Autentikointipalvelu järkevä pitää piilossa julkisesta internetistä ja tarjota väliin abstraktiokerros. Tämä abstraktiokerros on OpenID, OAuth, SAML tms -- ja sitä käytetään HTTP:llä. Tällöin sisäisen toteutuksen voi vaihtaa, mutta ulkoinen rajapinta ei muutu.

  HTTP rules erityisesti silloin kun user-agenttina on selain. Miksi rules myös natiiviapplikaatioissa ja SOA:ssa?
  Kun OAuth vie IdP:lle HTTP:llä, selain näyttää osoiterivillä idp:n domainin ja selainkontekstin turvallisuusilmoitukset (lukon kuva jne). Jos kertakirjaútuminen tapahtuisi HTTP:n sijaan esim. Kerberoksella tai muulla, web-selain ei osaisi kommunikoida ellei pluginia tai toteutusta. Tällöin kolmannen osapuolen palvelu joutuisi kysymään käyttäjän idp:n salasanaa suoraan ja hoitamaan autentikoinnin back-channelissa käyttäjältä näkymättömissä.
  Kun HTTP on yhteinen protokolla, selainta voi käyttää kaikkeen. Lisäksi Javascriptin yleistyminen: nykyisellään trendinä on selaimessa suoritettavan koodin runsastuminen (etsi Fat Clients -lähde).

  Sisäänkirjautuminen voi alkuvahvistusten jälkeen tapahtua ''suoraan'' ilman että käyttäjältä kysytään yhtään mitään, kun käyttäjä sisäänkirjautunut valmiiksi facebookiin. Esimerkiksi painaa pelkästään ''login''-nappia, palvelu käy salamannopeasti facebookissa (jossa voimassa oleva sessio) eikä käyttäjä huomaa mitään vaan on jo sisäänkirjautunut identiteetinkuluttajan palveluun.

  Autentikointipalvelujen keskittyminen. Soundcloud ei suosittele enää 3rd party devaajille password auth flowta, koska ''With the introduction of Login with Facebook we discourage the use of this flow since a lot of users simply don't have a password set anymore and thus can't use this flow.''

  Ulkoistamalla autentikoinnin identiteetintarjoajalle, MOOC-palvelun ei tarvitse luoda, ylläpitää ja turvata käyttäjätunnusten ja salasanojen tietokantaa.

  Selitä kertakirjautumisarkkitehtuuri, kuva~\ref{fig:kertakirjautumisarkkitehtuurin_yleiskuva}.
  \begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{images/NIST_authentication_architectural_model.jpg}
    \caption{NIST-organisaation suositus autentikoinnin arkkitehtuurimallista \cite{NIST_SP800-63-1} (todo selitä kuva) }
    \label{fig:kertakirjautumisarkkitehtuurin_yleiskuva}
  \end{figure}


  % Onko Shibboleth relevantti? % https://wiki.shibboleth.net/confluence/display/SHIB2/UnderstandingShibboleth
  % Miten Shibboleth ja SAML eroavat toisistaan? % http://shibboleth.internet2.edu/Shibboleth-SAML-FAQ.html
  % Onko Information Cards relevantti?
  % Onko User Provisioning käsitteenä relevantti?
  % Onko WS-Trust ja WS-Federation relevantteja?
  % Mikä on ''Circle of Trust?'' Onko se federated identityn juttu? Tarvitaanko sitä? Onko sama kuin PGP/GPG:ssä?

  % - ''AD FS can interact with other WS-* and SAML 2.0 compliant federation services as federation partners.''
  %   % http://en.wikipedia.org/wiki/Active_Directory_Federation_Services




  % http://developers.soundcloud.com/docs/api/authentication#user-credentials-flow




  Julkinen palvelu pilvessä vs. yksityinen palvelu organisaation sisäverkossa. Erilaiset tarpeet. Miljoona erilaista toteutusta. Julkisessa pilvessä niin paljon toimijoita, että ei voi olla montaa rinnakkaista standardia, vain muutama voi levitä yhtäaikaa laajalle. Historia: Ennen oli monta sisäänkirjautumiskuvaketta (esim 20 kuvaketta tai vapaa openid-url-kenttä). Nykyisellään käytännössä vain facebook, google, twitter -kuvakkeet. OpenID on olemassa mutta idea käyttäjäkeskeisyydestä on painunut taustalle.

  Tässä esitellään relevantein osin case MOOC, ja millainen tarve siinä on kertakirjautumiselle.


  Selitä kuva~\ref{fig:mooc_login_luonnos}.

  \begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{images/mooc_login_sketch.jpg}
    \caption{Luonnos MOOC-järjestelmän sisäänkirjautumissivusta. Missä tunnuksen luominen tapahtuu?}
    \label{fig:mooc_login_luonnos}
  \end{figure}


  Mitään tässä tutkielmassa esiteltävää protokollaa ei ole suositeltavaa implementoida omatoimisesti ilman painavaa syytä. Protokollan toteutuksen turvallisuus tai toimintavarmuus saattaa vaarantua pienestäkin virheestä. Jokaiselle tutkielmassa käsiteltävälle protokollalle on olemassa runsas joukko laajasti käytössä olevia kirjastoja, jotka ovat testattuja, ylläpidettyjä ja lisäksi myös jatkuvasti paremmaksi kehittyviä.

  Tässä kerrotaan mikä on federoitu identiteetti ja mikä delegoitu identiteetti.
  Jos käyttäjällä ei mahdollisuutta valita omaa identiteetintarjoajaansa, OpenID, OAuth tai SAML on vain sisäisen toteutuksen yksityiskohta. Jos idc-palvelulla merkittävä API-riippuvuus tiettyyn palveluntarjoajaan, OpenID ei tarjoa mitään, mitä OAuthilla ei voisi saada. Esimerkiksi Twitter-sidonnainen sovellus tarvitsee pääsyn nimenomaan Twitter-käyttäjätiliin. Tällöin on sovelluksesta johtuen täysin järkevää hyväksyä sisäänkirjautuminen vain Twitter-käyttäjätunnuksella. Vastaavasti käyttäjän sosiaalista verkostoa hyödyntävä Sofanatics (kuva~\ref{fig:facebook_oauth_login}) hyväksyy pelkän Facebook-tunnuksen, koska palvelun tärkeimpiä ominaisuuksia on kerätä ja välittää tietoa ottelutapahtumista Facebookiin.

  SAML ja OpenID -vertailu \cite{venn_of_identity_2008}
  % http://hueniverse.com/2009/04/introducing-sign-in-with-twitter-oauth-style-connect/
  %
  % OpenID is often described as a single-sign-on solution, or “the last username and password you will ever need”. OpenID is a federated authentication protocol – a protocol where users can use credentials from any compatible provider who can “speak” the OpenID protocol. But in this case, not any account will do. Twitter applications need Twitter accounts.
  %
  % It is important to understand that there are two different kind of single-sign-on solutions: delegated and federated. All the recent comparisons between OpenID and Facebook Connect failed to appreciate this fundamental difference. Facebook Connect is a delegated authentication service, while OpenID is a federated authentication service. They might offer very similar features, but they are very different.
  %
  % A delegated solution means that one site is simply outsourcing its authentication needs to another pre-selected site. If your site uses Facebook Connect, you are delegating your authentication facilities to Facebook. Visitors to your site cannot use any other accounts, only accounts from the vendors you have pre-selected.
  %
  % A federated solution means that visitors to your site can use any account they have, as long as it is compatible. It makes no difference to the site which account is being used, as long as it can interoperate. At its core, OpenID is a federated solution because its most important feature is the ability to use any OpenID account with any OpenID-enabled service.
  %
  %A good example is stores accepting credit cards. A store that accepts any Visa card is using federated payments – payments from any account that “speaks Visa”. But a store that accepts only credit cards issued by a specific vendor, for example, a department store branded card, use delegated payments. The reason why you no longer see many stores accepting only their own credit cards, is because it is bad for business.
  %
  % But not every OpenID implementation is federated, and this is the big dilemma OpenID has to resolve.
  %   -- linkki http://hueniverse.com/2009/02/does-openid-have-an-identity-crisis/
  %
  % The question is, can users use any account they want? If a site uses the Yahoo! OpenID service by using the Yahoo! button: xx
  %   but does not offer the ability to use other vendors, it is really just another delegated solution, even if it is powered by OpenID under the hood. In this case, OpenID becomes just a technical detail of the implementation, not part of its design.
  %
  % Much of the recent discussion about OpenID usability centers around using brands as a way to make the service more usable. But the problem with this approach is that is takes away most of the federated value out of OpenID, leaving it simply as a common protocol to implement proprietary delegated services. When implemented this way, OpenID adds no real value to services with an OAuth API.
  %
  % The question which solution to use for sign-in, OpenID or OAuth, is very much application specific. If you are building a brand new site that needs accounts, and want to leverage existing accounts from services such as Google, Yahoo!, and Microsoft, OpenID is a great option that will give your users a lot of flexibility. But if you are extending an existing service, implementing a specific API and building a site that has great dependencies on another service, OAuth gives you everything you need, for very little extra work.



  % paragraph yleisnäkymä_ilmakuva_overview (end)

  \subsection{SAML v2.0} % (fold)
  \label{sub:saml_v2_0}
  SAML ja SOAP.

  SAML on monipuolisempi ja sitä kautta monimutkaisempi kuin OAuth ja OpenID. Viimeksimainitut toimivat lähtökohtaisesti HTTP:n avulla. SAML mahdollistaa myös muita tapoja \emph{bindings}.

  Havainto: SAML-papereissa ei puhuta mitään OAuthista tai RESTistä. Ainoastaan WS-*, Shibboleth, XACML, ID-FF (jne) mainitaan.

  SAML käyttää XML Encryption ja XML Signature -standardeja eheyden ja luotettavuuden saavuttamiseksi.
  Niiden osalta viestinvälityskerroksen (transport layer) suojaaminen ei välttämätöntä, jos WS-Security.
  HTTPS:n käyttäminen on kuitenkin yksinkertaista ja vähentää kryptografiaan aiheuttamaa kuormitus-overheadia.
  Erikseen määritellyissä tapauksissa SAML edellyttää (\emph{mandate}) viestinvälityskerroksen suojaamista SSL/TLS:llä ja viestikerroksen (message-level, todo vai onko applikaatiolevel?) suojaamista XML Encryption ja XML Signature -standardilla.

  SAML-assertiot ja SAML-protokollat määritellään pohjautuen XML Schema -standardiin.
  SAML exchanges ilmaistaan muodoltaan standardoidulla XML-murteella, josta myös SAMLin nimi on peräisin (Security Assertion Markup Language). (viite
  %http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language)


  % For real, mitä eroa on OAuth ja SAML
  % https://www.pingidentity.com/resource-center/oauth-essentials.cfm
  % https://www.pingidentity.com/resource-center/SAML-Tutorials-and-Resources.cfm

  % subsection saml_v2_0 (end)

  SAML v2.0: Rakentuu Shibbolething ja Liberty ID-FF:n toiminnallisuuden päälle.

  Määrittele SAML-assertio. Onko assertio Suomea?

  SAML ja REST % http://saml.xml.org/news/how-to-use-saml-with-rest-web-services
  ''Best practice is to conform to the SAML v2 Web Profile. But the problem there is that the Web Profile relies on sessions, typically managed by cookies. Sessions are a stateful artifact that are contrary to REST.'' -- puristien mielestä joo, mutta Fielding eri mieltä: sessio on sama käyttäjälle itselleen, jolloin saman käyttäjän peräkkäiset requestit on aina restin mukaisia (sama uri+parametrit antaa aina saman vastineen).
  OAuth 2.0 sen sijaan (by design) hyödyntää HTTP-otsakkeita eikä vaadi sessiota.

  Federoidun identiteetin standardien kehitys on esitetty kuvassa~\ref{fig:federoidun_id_standardien_kehitys}. Vaikka vertailu on laadittu vuonna 2010, nuoremman sukupolven OAuth ei ole mukana.

  \begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{images/federoidun_id_standardien_kehitys.jpg}
    \caption{Federoidun identiteetin standardien kehitys~\cite{ping_identity_primer_federated_id_2010}.}
    \label{fig:federoidun_id_standardien_kehitys}
  \end{figure}


  \subsubsection{SAMLin johdannaiset ja SAMLiin liittyvät tekniikat} % (fold)
  \label{ssub:samlin_johdannaiset}


  \paragraph{ID-FF} % (fold)
  \label{par:id_ff}
  Liberty Alliancen Identity Federation Frameworkin (ID-FF) pohjalla oli SAML v1.1, jonka päälle Liberty toteutti lisää toiminnallisuutta.
  Liberty Alliance tunnusti tarpeen yhdelle federated SSO:n standardille, joten Alliance tarjosi ID-FF v1.2:n takaisin OASIS-yhteisen tekniselle komitealle inputtina SAML v2.0:n rakentamiseksi.
  Libertyn nykyinen web-tunnistautumisen framework on ID-WSF, joka käyttää SAML v2.0:aa autentikointi- ja auktorisointitietojen välittämiseksi web-palvelujen välillä.

  ID-FF v1.2 ei yhteisistä juurista huolimatta ole kuitenkaan yhteensopiva SAML v2.0:n kanssa (viite https://wiki.shibboleth.net/confluence/display/SHIB/SAMLLibertyDiffs).

  % paragraph id_ff (end)

  \paragraph{Shibboleth} % (fold)
  \label{par:saml_vs_shibboleth}
  Tässä kappaleessa kerrotaan, miksi gradussa käytetään SAMLia eikä Shibbolethia. Tai sitten perustellaan miksi käytetään Shibbolethia eikä SAMLia.

  % paragraph saml_vs_shibboleth (end)

  \paragraph{XACML} % (fold)
  \label{par:xacml}
  Tässä kappaleessa kerrotaan, miksei XACML ole relevantti gradun kannalta. Liittyy auktorisointiin, jota gradu ei käsittele.

  % paragraph xacml (end)

  \paragraph{WS-Security} % (fold)
  \label{par:ws_security}
  WS-Security on OASIS-komitean standardi, joka määrittelee tavan varmistaa SOAP-viestien eheys (integrity) ja luottamuksellisuus (confidentiality) (viite saml exec overview).

  WS-Security määrittelee turvallisuuspolettien (\emph{security tokens}) käsitteen, johon WS-*-arkkitehtuurityylin tietoturvanäkökulma perustuu.
  Turvallisuuspoletti sisältää SOAP-viestiin liittyvän identiteetti- ja pääsyoikeustiedon.
  WS-Securityssä on \emph{profiileja}, jotka määrittelevät yksityiskohdat turvallisuuspoletin käyttämiselle ja turvallisuuspoletin formaatin (todo käsite).
  Tuettuja formaatteja ovat esimerkiksi X.509-sertifikaatit (todo käsite) ja Kerberos-lipukkeet (Kerberos tickets, todo käsite).

  SAML Token Profile määrittelee SAML-assertioiden käytön WS-Securityn turvallisuuspolettina (viite saml exec overview).
  SAML-standardi esittää WS-Securityn hyväksyttynä menetelmänä suojata SOAP-viestit, jotka kuljettavat SAML-protokollatietoja tai -assertioita.

  % Jos transport layer security niin WSS:ä ei tarvita yhteyden suojaamiseen. Vähentää silloin myös overheadia jos ei WSS-kryptoa.
  % Saatetaan tarvita jos SAML vaikka HTTPS?

  % paragraph ws_security (end)
  % subsection samlin_johdannaiset (end)



  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \subsection{OpenID v2.0} % (fold)
  \label{sub:openid}

  todo: OpenID käyttää termeinä relying party (rp) ja identity provider (idp). Tässä tutkielmassa käytetään johdonmukaisesti aina identiteetinkuluttaja (= rp) ja identiteetintarjoaja.

  OpenID 2.0 on vuonna 2007 (todo) alkunsa saanut yhteiskäytön standardi, jonka tavoitteena on mahdollisuus käyttää samaa identiteettiä (käyttäjätunnusta) kaikissa web-palveluissa. OpenID-yhteisöstä ja -teknologian kehittämisestä vastaa OpenID Foundation (viite \url{http://openid.net/foundation/}) -niminen voittoa tavoittelematon järjestö. Järjestöön on sitoutunut pysyvinä jäseninä lukuisia suuria kansainvälisiä yrityksiä kuten Google, Microsoft, Symantec ja Yahoo! (viite \url{http://openid.net/foundation/sponsoring-members/}). Monet järjestön suurimmista tukijoista toimivat asiakkailleen OpenID-identiteetintarjoajana, minkä ansiosta OpenID-käyttäjäkunnalla on suuri kasvupotentiaali.

  % todo korvaa XXX
  OpenID-protokolla on suunniteltu siten, ettei identiteetinkuluttajan tarvitse tuntea identiteetintarjoajaa etukäteen. Tämän ansiosta protokolla toteuttaa \emph{käyttäjäkeskeisen identiteetin} (\emph{user centric identity}) periaatteen, jossa käyttäjä voi vapaasti valita oman identiteetintarjoajansa~\cite{openid_recordon_2009}. Tällöin käyttäjä voisi käyttää itse valitsemaansa identiteetintarjoajaa kaikissa OpenID:tä tukevissa palveluissa. Käytännössä palveluntuottaja kuitenkin edelleen valitsee identiteetintarjoajan: maailman XXX suosituimmasta OpenID:tä tukevasta web-palvelusta ainoastaan XXX hyväksyy vapaavalintaisen OpenID-identiteetintarjoajan. On yleistä, että palveluntuottaja hyväksyy ainoastaan oman organisaationsa identiteetintarjoajana tai suppean listan esivalittuja identiteetintarjoajia (kuva~\ref{fig:yahoo_login}).

  OpenID:tä voi käyttää myös palveluperustaisen arkkitehtuurin sisäisenä autentikointiratkaisuna. Esimerkiksi Amazon käyttää OpenID:tä laajan palvelujoukkonsa autentikointimentelmänä. Amazon hyväksyy ainoastaan oman identiteetintarjoajansa, mutta lukemattomat Amazonin omat palvelut voivat käyttää Amazonin OpenID-autentikointipalvelua käyttäjän tunnistamiseksi. Kuvassa~\ref{fig:amazon_openid} OpenID-parametrit ovat nähtävillä Amazonin AWS-sisäänkirjautumissivulla -- muita jälkiä OpenID:n käytöstä ei peruskäyttäjälle näy.

  \begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{images/amazon_openid.jpg}
    \caption{Amazon käyttää sisäisesti OpenID:tä autentikoidakseen käyttäjän palveluihinsa. Amazon on hyväksynyt  OpenID-identiteetintarjoajaksi ainoastaan itsensä.}
    \label{fig:amazon_openid}
  \end{figure}


  OpenID 2.0:ssa on kaksi flow'ta (todo termi) identiteetin etsimiseksi: \emph{suunnattu identiteetti}  (\emph{directed identity}) ja \emph{väitetty identiteetti} (\emph{claimed identity}) (todo viite \url{http://hueniverse.com/2009/07/users-vs-identity-providers-in-openid/}). Suunnatun identiteetin flow'ssa käyttäjä kertoo identiteetinkuluttajalle identiteetintarjoajan kaikille asiakkaillensa yhteisen OpenID-päätepisteen~\cite{openid_discovery_recordon_2008}. Tämä voi tapahtua klikkaamalla esivalitun identiteetin logoa tai syöttämällä identiteetintarjoajan URI OpenID-sisäänkirjautumiskenttään. Suunnatun identiteetin hyvänä puolena anonymiteetti: OpenID-tunnisteesta ei suoraan käy ilmi käyttäjän henkilöllisyyteen liittyviä tunnistetietoja, koska yksilöivä tunniste on tyypillisesti satunnainen merkkijono. Tämän ansiosta käyttäjän identiteettiä ei voida päätellä tai jäljittää OpenID-tunnisteesta ilman identiteetintarjoajan apua -- toisin kuin jos käyttäjätunnuksena olisi henkilökohtainen verkkotunnus tai sähköpostiosoite.

  \begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{images/yahoo_login.jpg}
    \caption{Sisäänkirjautuminen Yahoo!-palveluun. Kaksi esivalittua identiteetintarjoajaa oman lisäksi.}
    \label{fig:yahoo_login}
  \end{figure}

  Väitetyn identiteetin flow'ssa identiteetinkuluttaja etsii käyttäjän OpenID-tunnisteen perusteella siihen kytketyn identiteetintarjoajan. Käyttäjäkeskeinen OpenID-identiteetintarjoaja ei ole lähtökohtaisesti luotettu, koska kuka tahansa voi ryhtyä OpenID-identiteetintarjoajaksi. Identiteetinkuluttaja luottaa ainoastaan OpenID-identiteetintarjoajan sanomaan siitä, että käyttäjän esittämä OpenID-identiteetti on hänen hallinnassaan. Identiteetinkuluttaja ei siis tunne käyttäjän salasanaa eikä identiteetintarjoajaa, vaan ainoastaan käyttäjän yksilöivän OpenID-käyttäjätunnuksen. Väitetyn identiteetin OpenID-käyttäjätunnus on yleensä muistettavissa oleva URL-osoite kuten esimerkiksi \url!https://petrusrepo.myopenid.com!, \url!https://myopenid.com/repo! tai \url{https://petrus.repo.fi}. Sen sijaan esimerkiksi Googlen myöntämä suunnatun identiteetin OpenID-tunniste on muotoa
  \\ \verb#https://www.google.com/accounts/o8/id?id=<uniikki satunnaismerkkijono>#.
  % todo tsekkaa rivitys

    Googlen ja Yahoon käyttäjätutkimusten mukaan käyttäjät eivät tunne OpenID:n brändiä, mutta he tuntevat identiteetintarjoajansa brändin. Yritysten omien tutkimustulosten mukaan autentikoituminen on käyttäjäystävällisempää identiteetintarjoajan logon ja nimen sisältävän kuvan kuin vapaavalintaisen syöttökentän kautta~\cite{google_usability_federated_login, yahoo_usability_openid_2008, google_thoughts_combining_ux_2008}. Tällöin OpenID-etsintävaihe käynnistyy tyypillisesti klikkaamalla identiteetintarjoajan logoa (kuva~\ref{fig:yahoo_login}). Logon käyttämistä sisäänkirjautumissivulla suosittelevat identiteetintarjoajat tarjoavat usein suunnatun identiteetin toteutuksen, jolloin identiteetintarjoajan OpenID-päätepiste on sama kaikille sen
    asiakkaille\footnote{Suunnatun identiteetin OpenID-päätepiste on Yahoolla \url!https://yahoo.com! ja
                      \\ Googlella \url!https://www.google.com/accounts/o8/id!}.
Googlen suositus logon käyttämisestä on toteutettu käytännössä siten, että OpenID-päätepistettä tai -tunnistetta ei ole tarkoituskaan muistaa ulkoa.
  %   Identiteetin kuluttaja aloittaa etsintävaiheen ottamalla yhteyden käyttäjätunnuksen tai suunnatun identiteetin URL-osoitteeseen.

  Käyttäjäkeskeinen identiteetti toteutuisi ihanteellisesti siten, että käyttäjän OpenID-tunniste olisi hänen omassa hallinnassaan. Tällöin tunnisteena olisi käyttäjän oma verkkotunnus kuten \url{https://petrus.repo.fi} tai sähköpostiosoite \url{petrus@repo.fi}. Oman verkkotunnuksen voi säilyttää sukupolvelta toiselle, kun taas yrityksen nimeen kytketty verkkotunnus saattaa poistua käytöstä esimerkiksi yrityksen lopettaessa toimintansa. Suunnatun identiteetin kritiikkinä on esitetty, että kun käyttäjän ei tarvitse tuntea omaa OpenID-tunnistettaan vaan ainoastaan sitä hallinnoivan yrityksen logo, mihin OpenID:n käyttäjäkeskeisyyttä, yhteisöä ja yhteistä standardia lopulta tarvitaan (todo viite \url{http://hueniverse.com/2009/02/does-openid-have-an-identity-crisis/})? Toistaiseksi on ollut suurten yritysten intresseissä tukea avoimia standardeja kuten OAuth ja OpenID. Silti esimerkiksi Microsoftin Windows Live -palvelu vuonna 2008 aloitti kokeilun toimiakseen OpenID-identiteetintarjoajana\footnote{Microsfot Windows Live julisti aloittavansa OpenID-identiteetintarjoajana vuonna 2008 \url{http://www.readwriteweb.com/archives/microsoft_windows_live_openid.php}}, mutta myöhemmin tämä tuki lopetettiin\footnote{Windows Liven kehittäjäverkostosta ei löydy yhtään artikkelia hakusanalla ''openid'' tammikuussa 2012 \url{http://windowsteamblog.com/search/searchresults.aspx?q=openid}}.

  % Tällöin myös käyttäjän identiteetin OpenID-tunniste muuttuu, jos siinä on käytetty lopettaneen yrityksen käytöstä poistuvaa verkkotunnusta. Lukuisat OpenID-identiteetintarjoajat mahdollistavat oman verkkotunnuksen käytön OpenID-tunnisteessa -- esimerkiksi Google Apps ja Yahoo!. Jos identiteetintarjoaja ei suoraan mahdollista oman verkkotunnuksen käyttöä, se voi silti olla mahdollista OpenID-delegoinnilla.

  OpenID on single point of failure jos idp menee nurin. Tällöin idp:n käyttäjät eivät voi sisäänkirjautua palveluun. IDP:tä ei voi myöskään vaihtaa ilman että pääsee kirjautumaan sisään. Kannattaa tukea mahdollisuutta liittää monta identiteettiä samaan käyttäjätunnukseen (mutta se on epäkäytännöllistä). Ongelman välttämiseksi voi olla käytännöllistä tukea ainoastaan esivalittuja suuria identiteetintarjoajia. Jos kurssilla 10.000 opiskelijaa ja käyttäjäkunnasta 0,1~\% käyttää kaatunutta identiteetintarjoajaa, seurauksena 10 potentiaalista support-viestiä, jotka jonkun täytyy käsitellä kaiken muun kiireensä keskellä.

  Toinen single point of failure: jos joku pöllii salasanan. Yksi tunnus kaikkiin palveluihin. Yksi pölliminen johtaa moneen pöllimiseen. OpenID:n idc ja idp eivät tunne toisiaan--> openid-idp:n haltuunsa palauttanut käyttäjä ei voi poistaa oikeuksia idc:ltä (kuten oauthissa). Tällöin myöskään sessiot hyökkääjän ja idc:n välillä ei vanhene jos hyökkääjä ehtinyt avata sellaisen (toisin kuin oauthissa).




  \subsubsection{OpenID-autentikoinnin vaiheet} % (fold)
  \label{ssub:openid_autentikoinnin_vaiheet}

  Identiteetin todentaminen käynnistyy etsintävaiheella (\emph{discovery phase}), jossa käyttäjän syöttämän OpenID-päätepisteen (\emph{endpoint}) perusteella identiteetinkuluttaja etsii OpenID-tunnisteen identiteetintarjoajan. Käytännössä OpenID-päätepisteenä toimii joko OpenID-käyttäjätunnus (yksilöivä tunniste) tai identiteetintarjoajan kaikille asiakkaille yhteinen URL-osoite (suunnattu identiteetti). OpenID-etsintävaiheen ansiosta identiteetinkuluttajan ei tarvitse tuntea identiteetintarjoajaa etukäteen. Identiteetinkuluttaja voi myös hyväksyä ainoastaan yhden esivalitun identiteetintarjoajan tai listan sellaisista. Hyväksymällä identiteetintarjoajiksi Google ja Facebook saavutetaan XX \% internetin käyttäjistä (todo luku ja viite). Hyväksymällä ainoastaan yksi identiteetintarjoaja kyseessä on federoitu identiteetti, koska käyttäjällä ei ole enää mahdollisuutta itse valita identiteetintarjoajaansa (todo onko näin binääristä).

  OpenID-identiteetin todentaminen osoittaa ainoastaan, että jokin OpenID-identiteetti on käyttäjän hallinnassa. OpenID-protokolla ei ota kantaa identiteetintarjoajan suorittaman autentikoinnin tasoon. On täysin mahdollista toteuttaa identiteetintarjoaja, joka vastaa kaikkiin identiteettikyselyihin hyväksyvästi eikä siten takaa mikäänlaista käyttäjän tunnistetietojen varmentamista. Sen vuoksi identiteetinkuluttajan kannalta voi olla järkevää hyväksyä vain yksi tai useampi ennalta valittu identiteetintarjoaja, jolla on vakaa ja luotettava maine.


  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/openid_flow_recordon06.jpg}
    \caption{OpenID-autentikoinnin vaiheet~\cite{openid_recordon_2009} (todo en pidä tästä kuvasta, piirrä parempi)}
    \label{fig:basic_openid_flow}
  \end{figure}

  OpenID 2.0 -autentikointi (kuva~\ref{fig:basic_openid_flow}) sisältää seuraavat vaiheet.

  todo listaelementti

  1. Käyttäjä käynnistää autentikointiprosessin esittämälle identiteetinkuluttajalle OpenID-päätepisteen. OpenID-päätepisteenä toimii joko käyttäjän yksilöivä OpenID-tunniste (\url{https://petrus.repo.fi}) tai identiteetintarjoajan kaikille käyttäjille yhteinen URI (\url{https://yahoo.com}).

  2. Identiteetinkuluttaja (relying party) suorittaa etsintäprosessin (discovery process). Etsinnän lopputuloksena on OpenID-päätepisteeseen kytketty OpenID-identiteetintarjoaja. Todo selvitä miten tässä yhteydessä diffie-hellman ja back-channel, voiko idp ja idc jutella keskenään tämän jälkeen taustalla.

  3. Identiteetinkuluttaja luo käyttäjän autentikointipyyntöä varten jaetun salaisuuden identiteetintarjoajan kanssa.

  4. Identiteetinkuluttaja uudelleenohjaa käyttäjän (todo termi käyttäjän, asiakkaan vai user-agentin) edellisessä vaiheessa luodun salaisuuden kanssa OpenID-identiteetintarjoajan palveluun.

  5. OpenID-identiteetintarjoaja autentikoi käyttäjän. Protokolla ei ota kantaa siihen, miten autentikointi tapahtuu.

  6. Identiteetintarjoaja uudelleenohjaa käyttäjän (todo termi) identiteetinkuluttajan palveluun. Käyttäjä saa kannettavakseen jaetun salaisuuden perusteella laaditun poletin (todo termi ''cryptographic proof'') sekä mahdollista käyttäjäprofiiliin liittyvää dataa kuten sähköpostiosoitteen.

  7. Identiteetinkuluttaja vastaanottaa käyttäjän pyynnön, varmistaa poletin ja hyväksyy käyttäjän sisäänkirjautumisen.


  Määrittele termit speksistä: identifier, claimed identifier, verified identifier, identity provider.
  Puhutaanko aina identiteetin kuluttajasta vai pitäisikö käyttää myös termiä relying party?

  ''How the End User authenticates to their Identity Provider is outside of the scope of OpenID Authenticaiton.'' (viite speksi)

  Erään tutkimuksen mukaan OpenID-tunnisteista 98~\% on http ja vain 2~\% https~\cite{openid_identifier_survey_2011}.
  Koska user-agenttia uudelleenohjataan identiteetinkuluttajan ja identiteetintarjoajan välillä, suojaamaton yhteys on haavoittuvainen DNS- ja man-in-the-middle -hyökkäyksille.
  % lue ja viittaa myös http://wiki.openid.net/w/page/12995200/OpenID%20Security%20Best%20Practices

  % XRDS Discovery https://sites.google.com/site/oauthgoog/fedlogininterp/openiddiscovery

  % email address discovery: http://hueniverse.com/2009/10/email-addresses-as-openids/

  % openid nascar problem (haluaa nähdä vain googlen logon):
  % http://factoryjoe.com/blog/2009/04/06/does-openid-need-to-be-hard/


  % \subsubsection{XRI ja Directed Identity} % (fold)
  % \label{ssub:xri_ja_directed_identity}
  %
  % Current speciﬁcation of OpenID [1] states that an OpenID
  % identiﬁer is either a ”http” or ”https” URI [...] , or an XRI.
  % We classiﬁed only http and https identiﬁers, ignoring XRI.
  % The reasons are that almost nobody uses XRI, there is not
  % support in current browsers to resolve XRI and there is not
  % a standard way to get a HTML document from them.
  % -- A survey on OpenID identiﬁers
  %
  %
  % XRI on yhdentyyppinen URI



  % XRDS service links are all related to the OpenID protocol, despite XRDS
  % supports discovery of other types of services. Beyond authentication, OpenID
  % Simple Registration Extension and OpenID Attribute Exchange are popular
  % OpenID extensions supported by collected identiﬁers. They are followed by
  % provider policy authentication extensions (PAPE), which assert policies
  % applied by identity providers in order to assure end user authentication.
  % The most popular is phishing-resistant policies. The rest of services are
  % less common. \cite{openid_identifier_survey_2011}



  %  The premise of OpenID 1.x was that users would share one
    % globally unique URL (or one of a presumably small set of URLs)
    % with RPs. This stood in stark contrast to other Internet identity
    % frameworks such as Liberty Alliance ID-WSF and Information
    % Cards, which go to great lengths to use pairwise identifiers so
    % they introduce no new correlation handles at the protocol level.
    %     OpenID Authentication 2.0 addressed this issue by adding support
    % for “directed identity”—a term for the use of pairwise-unique
    % identifiers coined by Microsoft Chief Identity Architect Kim
    % Cameron [23]. This was accomplished by adding the new service
    % endpoint type “http://specs.openid.net/auth/2.0/identifier_select”.
    % When a user enters an OpenID identifier resolving to a service
    % endpoint of this type (typically by entering the URL or i-name of
    % their OpenID provider, rather than their own OpenID identifier),
    % the RP knows it must ask the OP for the user’s identifier. The OP
    % can then offer the user the choice of using one of their existing
    % OpenID identifiers, or having the OP generate a pairwise-unique
    % identifier for this specific relationship. In fact the user need not
    % know or remember this identifier as the OP can store and
    % automatically use it in future logins to the same RP.
    %     This directed identity feature  works with both URLs and XRIs,
    % however by assigning XRI i-numbers in the OP’s own XRI
    % delegation space, OPs can take advantage of their persistence and
    % security features discussed above.
  % subsubsection xri_ja_directed_identity (end)

  % subsubsection openid_autentikoinnin_vaiheet (end)

  \subsubsection{Identiteetin delegointi} % (fold)
  \label{ssub:identiteetin_delegointi}

  Selitetään mahdollisuus kytkeä oma verkkotunnus kolmannen osapuolen identitarjoaan delegoimalla identiteetti.

  Käyttäjä --identiteetti--> verkkotunnus --delegointi--> idp jossa login

  \begin{verbatim}
    <head>
    <link rel="openid2.provider"
      href="https://openid.stackexchange.com/openid/provider">
    <link rel="openid2.local_id"
      href="https://openid.stackexchange.com/user/a0cd3405-f76e-429e-b935">
    </head>

    todo viite http://blog.stackoverflow.com/2009/01/using-your-own-url-as-your-openid/
  \end{verbatim}

  Oman verkkotunnuksen hosting pitää olla turvallinen. Delegointia voi muuttaa jos pääsee käsiksi verkkotunnuksen tarjoamaan delegoinnin web-sivuun.
  Google ei tästä syystä tue delegointia.
  % subsubsection identiteetin_delegointi (end)


  % Google:
  % Guide to Running a User Account System
  % http://goo.gl/R8pMP

  % subsection openid (end)

  % \subsection{OpenID Connect} % (fold)
  % \label{sub:openid_connect}
  % OpenID Connect: yhdistää tiedon jakamisen (oauth) ja autentikoitumisen (openid)
  %
  % http://www.webmonkey.com/2010/05/new-openid-connect-proposal-could-solve-many-of-the-social-webs-woes/
  %
  %
  % Mitä eroa on OpenID Connect ja OAuth 2.0 ?
  % OAuth - palvelujen täytyy tuntea toisensa. Täytyykö OpenID-C:ssa?
  % Onko OpenID-C edelleen user-centric id?
  %
  % Mikä on OpenID Abstract Binding ? (https://www.pingidentity.com/resource-center/openid.cfm)
  %
  % The current OpenID version is 2.0. However a new version, OpenID AB/C, merges two different next-generation standards efforts, OpenID Abstract Binding and OpenID Connect, and is under construction. OpenID is a profiled protocol for the Federal ICAM initiative. OpenID 2.0 is only profiled for the lowest level of assurance described by the government guidance set out in NIST 800-63. Hopefully, the next generation of OpenID will be capable of all four assurance levels used today.
  %
  % Federal Identity, Credentialing, and Access Management % http://www.idmanagement.gov/documents/ICAM_OpenID20Profile.pdf
  %
  % ks http://stackoverflow.com/questions/3260557/openid-is-the-identifier-url-unique-what-are-the-differences-between-the-ident
  %
  % subsection openid_connect (end)




  % subsection autentikoituminen_käyttäjäkeskeisellä_identiteetillä (end)


  \subsection{OAuth v2.0} % (fold)
  \label{sub:oauth}

  \begin{quote}
    ''Many luxury cars come with a valet key. It is a special key you give the parking attendant and unlike your regular key, will only allow the car to be driven a short distance while blocking access to the trunk and the onboard cell phone. Regardless of the restrictions the valet key imposes, the idea is very clever. You give someone limited access to your car with a special key, while using another key to unlock everything else.''
    todo viite http://hueniverse.com/2010/05/introducing-oauth-2-0/
  \end{quote}

  % oauth 1.0a:
  % oauth_callback: url johon idp ohjaa käyttäjän autentikoinnin/auktorisoinnin jälkeen
  % out of band: ei url callbackia, mutta oauth_verifier haaste
  % requestToken: poletti joka myönnetään kysyjälle. uudelleenkäytetään auktorisointivaiheessa.
  % accessToken: poletti joka myönnetään auktorisointisyklin lopuksi. Toimii käyttäjän myöntämänä valtakirjana: valtakirjaa vastaan annetaan käyttöoikeus käyttäjän resursseihin.
  % authorize: Poletin vastaanottamisen jälkeen idp esittää auktorisointisivun jossa käyttäjä sallii/hylkää pääsyoikeuspyynnön
  % token secret: merkkijono joka palautetaan requestToken ja accessToken vaiheiden jälkeen, käytetään yhdessä consumer secretin kanssa kun pyyntö allekirjoitetaan
  % comsumer key: idc:n api-avain
  % consumer secert: idc:n api-salaisuus, jolla kaikki pyynnöt allekirjoitetaan
  % oauth_nonce: satunnaismerkkijono, uniikki joka pyynnöllä
  % oauth_timestamp: epoch time sekunteina, max synkronisointiero 5? minuuttia idc:n kelloon?
  % oauth_token: riippuu kontekstista: joko request token tai access token
  % oauth_verifier: idp palauttaa idc:lle oauth_callbackin kutsun yhteydessä, tai käyttäjä syöttää käsin out-of-band flowssa.
  %
  % kuinka request token rakennetaan? http method, request uri, oauth_callback, oauth_consumer_key, oauth_nonce, oauth_signature_method, oauth_timestamp, oauth_version
  % rakennetaan url, urlescape parametrit
  % lisätään url http authorization headeriin
  % lähetetään endpointtiin
  % jos onnistuu, tulee takaisin url encoodattu vastaus, jossa oauth_token, token_secret ja callback_confirmed=true:
  %    oauth-token on request token ja token_secretillä allekirjoitetaan pyyntö access_tokenista
  %     callback_confirmed -- vapaaehtoinen vai pakollinen? sanoo vain että ok
  %     säilytä oauth_token ja token_secret kunness access_token vaihe on valmis.
  % -- tämän jälkeen idc:llä on request token ja rakennetaan url auktorisointia varten.
  %  auktorisointi url endpoint on idp:llä, queryparametriksi oauth_token, jonka arvo on saatu edellisessä vaiheessa.
  % timestamp --> käyttäjän täytyy saapua <=5minuutissa ensimmäisen tokenin myöntämisen jälkeen. idp:llä on jo oauth_callback --> sitä ei enää tartte tässä syöttää.
  %
  % prepare your signing secret:
  % riippumatta käyttääkö callback vai out-of-band: idc:llä on request token, oauth_token_secret ja oauth_verifier. Request token vaihdetaan access_tokeniin, joka esittää valtakirjaa jolla idc saa (valtakirjan mukaiessti) toimia käyttäjän puolesta idp:n myöntämissä resursseissa.
  % signing key format: url_escape(consumer_secret)&url_escape(oauth_token_secret)
  % ---> rakenna url, lähetä authorisointitiedot http headereissa:
  %    oauth_signature, _nonce, _callback, _signature_method, _timestamp, _consumer_key, _token, _verifier, _version
  % ---> idp vastaa oauth_token ja oauth_token_secret, idc:n täytyy säilöä molemmat niin kauan aikaa kuin se käyttää valtakirjaa. Käyttäjä voi määritellä myös ajan kauanko valtakirja on voimassa. Käyttäjä voi myös poistaa valtakirjan (revoke token) milloin vain idp:n palvelussa. Myös idc voi omatoimisesti invalidoida tokeninsa.
  % Lähde:   http://www.slideshare.net/episod/linkedin-oauth-zero-to-hero

  % Jos käyttäjä painaa auktorisointipyyntöön cancel, voidaan palauttaa "integration urliin". Jos tätä ei määritetty, palautus callback_urliin. Tällöin idp ei välitä tokenia tai salaisuutta. Callback urliin lähetetään oauth_problem jonka arvona "user_refused".

  % Your servers making requests must be within 5 minutes of our system clock. Timestamps in OAuth are always represented in epoch time in seconds. In any error response LinkedIn sends you, the current timestamp on our servers is included in an XML body of the response. However, at this time the timestamp we send you is in milliseconds, not seconds. It's quite easy to do the math to convert milliseconds to seconds.

  % linkedin oauth 1.0a flow: https://developer.linkedin.com/documents/oauth-overview
  % twitter oauth 1.0a: https://dev.twitter.com/docs/auth/authorizing-request
  % https://dev.twitter.com/docs/auth/implementing-sign-twitter
  % twitter tokenit

  Better ux: app logo secure url: oauth pyynnön käyttäjälle näytettävällä sivulla voidaan esittää idc:n logo.

  OAuth autentikointiflow toimii kuten auktorisointi flow lukuunottamatta yhtä poikkeusta. Jos seuraavat kolme ehtoa täyttyvät:
  1) The current member is logged into LinkedIn.
  2) The current member has already granted an access token to your application.
  3) The access token has not expired.

  Niin IDP voi ohjata käyttäjän välittömästi callback urliin -- ilman keskeytymisiä. Hyvä UX: one-click login. Jos jokin em. ehdoista ei täyty, niin silloin normaali auktorisointiflow. (vrt. linkedin, sporttipalvelu josta kuva)
  % https://developer.linkedin.com/documents/linkedins-oauth-details

  *** 3-legged authorization: käyttäjältä kysytään AINA lupa vaikka app olisi auktorisoitu jo aiemmin. Ota kuva twitterin docseista. % https://dev.twitter.com/docs/auth/3-legged-authorization

  *** PIN Based authentication: Kun app ei voi embeddaa tai käyttää web-selainta käyttäjän uudelleenohjaamiseksi auktorisoinnin endpointtiin. Commandline-ohjelmat, embedded systems, pelikonsolit ja tietyntyyppiset mobiiliappsit. Toimii kuten normaali ja 3-legged, mutta oauth\_callbackin täytyy olla \verb!oob! POST oauth/request\_token -kutsussa. Kun app kehittänyt idp:n oauth/authenticate tai oauth/authorize URL:n, idc näyttää URL:n käyttäjälle joka syöttää sen käsin web-selaimeen. Idp autentikoi käyttäjän, mutta ei redirectaa takaisin appiin (koska käyttäjä avasi selaimen manuaalisesti). Sen sijaan idp tarjoaa PIN-koodin, jota idc seuraavaksi kysyy ja joka käyttäjän täytyy idc:lle syöttää. Ota kuva twitterin docseista. PIN-koodi annetaan \verb!oauth_verifier! arvona kun \verb!POST oauth/access_token!. Muut pyynnöt toimivat normaalisti.
    % https://dev.twitter.com/docs/auth/pin-based-authorization


  OAuth 1.0 syntyi sosiaalisen median tarpeesta jakaa käyttäjän dataa eri palvelujen kesken. Ennen OAuthia oli yleistä, että esimerkiksi Facebookista käyttäjän tietoja hakenut palvelu kysyi käyttäjän omaa Facebook-salasanaa ja käytti sitä tietojen noutamiseen. Tällaista voidaan kutsua salasana-antipatterniksi, koska käyttäjän salasana ei ole jakamisen jälkeen enää salainen: jokainen Facebookista tietoa hakeva palvelu tuntee käyttäjän salasanan. OAuth 1.0:n mahdollisti luvan kysymisen käyttäjältä ennen tietojen jakamista kolmannen osapuolen palvelun kesken. Kuitenkin ennen kaikkea sisäänkirjautuminen tehtiin ainoastaan dataa hallinnoivaan palveluun eikä salasanaa tarvinnut enää syöttää kolmannen osapuolen palveluun. Tällöin esimerkiksi pääsyoikeutta käyttäjän kuviin halunnut palvelu ohjasi käyttäjän Facebookiin, jonne käyttäjä syötti salasanansa. Sen jälkeen käyttäjällä oli mahdollisuus hyväksyä tai hylätä tämä käyttöoikeuspyyntö.

  Kolmannen osapuolen palvelu K voi siis pyytää käyttäjän tietoja palvelusta P ilman että P:n salasanaa tarvitsee syöttää K:hon. Käyttäjän täytyy hyväksyä tietojen pyytäminen, eli K ei saa noudetuksi P:n tietoja ilman käyttäjän lupaa.
  OAuth 2.0 on kokonaan uusi protokolla, joka ei ole taaksepäin yhteensopiva aiempien versioiden kanssa. OAuth 2.0 on vielä tätä tutkielmaa kirjoitettaessa luonnosvaiheessa (draft 22), mutta lopullinen versio valmistunee vuoden 2012 aikana. OAuth 1.0 syntyi pitkälti Twitterin ja Googlen omien auktorisointiprotokollien pohjalta. OAuth 2.0 on saanut merkittävästi vaikutteita Facebookilta, jonka valtaisan tietomäärän eri käyttötapauksiin aiempi OAuth 1 -standardi ei millään riittänyt. OAuth 1.0 + Facebook Connect --> OAuth 2.0. Auktorisoinnin lisäksi OAuth 2.0 tukee aiempaa versiotaan selvemmin myös autentikointia.

  OAuth 1.0 tuotti vastutusta kehittäjien keskuudessa. Ennen OAuthia esimerkiksi Twitter-integraatio onnistui HTTP Basic -autentikaatiolla, mikä mahdollisti käyttäjätietojen kyselyn yhdellä HTTP-pyynnöllä\footnote{HTTP Basic Auth mahdollistaa käyttäjätunnuksen ja salasanan välittämisen osana URL:a, esimerkiksi \url!http://tunnus:salasana@palvelu.com/polku!.}. OAuth 1.0 monimutkaisti järjestelyä merkittävästi, koska ulkopuolisella kehittäjällä ei ollut enää pääsyä käyttäjän salasanaan ja, erityisesti, koska tietoja ei pystynyt enää hakemaan ilman käyttäjän lupaa. Kehittäjäyhteistä tulleen muutosta vastustaneen negatiivisen palautteen jälkeen Twitter kehitti siirtymävaiheen avuksi xAuth-mentelmän\footnote{Twitterin xAuth on nimestänsä huolimatta eri asia kuin \url{XAuth.org}.}, jossa identiteetinkuluttaja kysyy käyttäjän salasanaa\footnote{xAuth on OAuth ilman \emph{request\_token} ja \emph{authorization} -vaiheita: identiteetintarjoaja antaa pääsyoikeuspoletin identiteetinkuluttajan tarjoamaa käyttäjätunnusta ja salasanaa vastaan. xAuth tarjoaa OAuthia rajoitetumman pääsyn käyttäjän profiiliin, ja sen käyttämiseksi täytyy anoa Twitteriltä erillinen lupa (\url{https://dev.twitter.com/docs/oauth/xauth}).}. OAuth 2.0 tuo mukanaan käyttäjätunnus ja salasana -flow:n, jolla xAuth voidaan tulevaisuudesa korvata, kun standardi valmistuu nykyisestä luonnosvaiheestaan.
  % taustaa:
  %      http://hueniverse.com/2009/02/beyond-the-oauth-web-redirection-flow/
  %      http://hueniverse.com/2010/05/introducing-oauth-2-0/

  Käyttäjälle muutos on kuitenkin positiivinen, koska kohdepalvelun salasanaa ei tarvitse jakaa kolmannelle osapuolelle. Jakammalla oman salasanansa kolmannen osapuolen palveluun, käyttäjä samalla antaa tälle palvelulle täydet oikeudet salasanansa suojaamiin resursseihin. Tällöin minkä tahansa kolmannen osapuolen tietomurto vaarantaa näiden resurssien kaiken datan, joka on suojattu kyseisellä salasana. Seurauksena ainoa tapa poistaa kolmannen osapuolen pääsyoikeus jälkikäteen on salasanan vaihtaminen. Tällöin kuitenkin pääsy estyy \emph{kaikilta} palveluilta, jotka ottavat resurssiin yhteyttä kyseisellä salasanalla.

  OAuth eriyttää toisistansa roolit resurssin omistajalle (käyttäjälle) ja resurssiin yhteyttä ottavalle kolmannen osapuolen palvelulle sekä luo näiden väliin auktorisointikerroksen (\emph{authorization layer})~\cite{ietf_oauth2}. OAuth-protokollassa asiakas (\emph{client}, esim. kolmannen osapuolen palvelu) pyytää pääsyoikeutta resurssiin, jota hallinnoi resurssin omistaja ja isännöi (todo: hosting suomeksi?) resurssin palvelin. Resurssin palvelimen käyttämä OAuth-auktorisointipalvelu (\emph{authorization server} luo resurssin omistajan hyväksynnällä jokaiselle asiakkaalle (kolmannen osapuolen palvelulle) itsenäisen valtakirjan. Yhden asiakkaan valtakirjan (pääsyoikeuksien) evääminen ei vaikuta muille asiakkaille myönnettyihin tai resurssin omistajan pääsyoikeuksiin. Tällaista valtakirjaa OAuth kutsuu pääsyoikeuspoletuksi (\emph{access token}, todo käännös).

  Asiakas ei tunne resurssin omistajan salasanaa, vaan esittää pääsyoikeuspoletin saadakseen käyttöoikeuden kohteena olevaan resurssiin. Pääsyoikeuspoletti sisältää tiedon kolmannelle osapuolelle myönnettyjen oikeuksien laajuudesta sekä oikeuksien voimassaoloajasta. Tällöin resurssin omistajalle on mahdollista tarjota näkyvyys siihen, minkä resurssien jakamiseen hän on myöntänyt luvan (todo kuva auktoroisoiduista sovelluksista). Facebookin Developer -sivustolla huomautetaan kolmannen osapuolen kehittäjiä, että mitä laajempaan joukkoon resursseja pyydetään käyttöoikeutta, sitä suurempi on oikeuksien myöntämisestä kieltäytyvä käyttäjäjoukko (todo lähdeviite https://developers.facebook.com/docs/authentication/). Tämä on merkittävä havainto, koska OAuthia edeltäneenä aikana oikeuksia ei käytännössä ollut mahdollisuutta rajata lainkaan, vaan kolmannen osapuolen palvelu pystyi tekemään saamallaan käyttäjän salasanalla mitä vain.

  OAuth on suunniteltu toimimaan ensisijaisesti HTTP-protokollalla~\cite{ietf_oauth2}.
  Standardi jättää määrittelemättä OAuthin käytön muulla kuin HTTP-protokollalla.

  Selitä auki kuva~\ref{fig:facebook_oauth_lupapyynto}.

  \begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{images/facebook_oauth_lupapyynto.jpg}
    \caption{OAuth-käyttöoikeuspyyntö Facebookissa. Osoiterivillä dataa hallinnoivan palvelun URL ja selainkontekstin turvallisuusilmoitus.}
    \label{fig:facebook_oauth_lupapyynto}
  \end{figure}



  Selitä auki kuva~\ref{fig:facebook_popup_login}.

  \begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{images/facebook_popup_login.jpg}
    \caption{OAuth-sisäänkirjautuminen Facebook-tunnuksilla kolmannen osapuolen palveuun. Identiteetintarjoajan osoite sekä turvallista yhteyttä kuvaava lukko ovat näkyvissä selainkontekstissa.}
    \label{fig:facebook_oauth_login}
  \end{figure}


  \subsubsection{OAuth käytännössä} % (fold)
  \label{ssub:oauth_käytännössä}

  OAuth 2.0 on suhteellisen yksinkertainen protokolla verrattuna edeltäjäänsä. OAuth-kuluttaja rekisteröidään OAuth-palveluntarjoajalle, kuluttaja ohjaa käyttäjäagentin URL-osoitteeseen, parsii tarjoajalta saamanstansa vastauksesta poletin ja lähettää tämän poletin palvelukutsun mukana tarjoajan rajapintaan. OAuth 2.0 -identiteetintarjoajan on tunnettava identiteetinkuluttaja etukäteen. OAuth-spesifikaatio ei kuitenkaan sulje pois ennalta tuntemattomia kuluttajia: tällainen laajennos voi myöhemmin syntyä OAuthiin (todo tähän oli varhaisessa vaiheessa oleva draft, viite).

  Vaiheet:
  % http://code.google.com/apis/accounts/docs/OAuth2.html

  1. \textbf{Kuluttajapalvelun rekisteröinti} Kuluttajapalvelu rekisteröidään tarjoajan palveluun. Rekisteröintiprosessin lopputuloksena on joukko erilaisia arvoja, jotka ovat sekä kuluttajan että tarjoajan tiedossa. Arvoja ovat tyypillisesti \verb!client_id!, \verb!client_secret! ja \verb!redirect_uri! -- näiden lukumäärä ja tyyppi vaihtelee kuluttajapalvelun tyypistä riippuen. Esimerkiksi JavsScript-sovellus ei tarvitse salaisuutta, mutta web-palvelu (kuten MOOC) tarvitsee.

  2. \textbf{Pääsyoikeuspoletin hankkiminen}
  Pääsyoikeuspoletti mahdollistaa eri tasoisia käyttöoikeuksia. Poletti voi toteuttaa pelkän sisäänkirjautumisen tai sillä voidaan lisäksi myöntää valtakirja käyttäjän hallinnoimiin resursseihin. Valtakirjan laajuus määräytyy poletin hankkimispyynnön yhteydessä \verb!scope!-parametrilla. Yksi pyyntö voi sisältää monta scope-näkyvyysalueparametria.

  Hankkimispyynnön yhteydessä käyttäjä autentikoituu identiteetintarjoajalle. Sisäänkirjautumisen jälkeen identiteetintarjoaja esittää identiteetinkuluttajan pyytämän valtakirjan, jonka käyttäjä joko hyväksyy tai hylkää. Tätä vaihetta kutsutaan on käyttäjän suostumukseksi (\emph{user consent}, kuva~\ref{google_id_and_user_consent}). Jos käyttäjä hyväksyy pyynnön, käyttäjäagentti ohjataan takaisin kuluttajapalveluun, jolle välitetään viestin yhteydessä joko pääsyoikeuspoletti tai pyyntöpoletti (jolla pääsyoikeuspoletti haetaan). Kun identiteetinkuluttaja on saanut pääsyoikeuspoletin, sen ei tarvitse enää kysyä seuraaviin pyyntöihin käyttäjän suostumusta niin kauan kuin poletti on voimassa. todo selitä tämä paremmin

  Pääsyoikeuspoletin hankkimistapoja on erilaisia -- valittava tapa riippuu kuluttajapalvelun luonteesta.
  Tämän tutkielman puitteissa esitellään tarkemmin web-palvelun kannalta kiinnostava flow.

  3. \textbf{Pääsyoikeuspoletin esittäminen}
  Hankkimisvaiheen jälkeen kuluttajapalvelu voi käyttää pääsyoikeuspolettia valtakirjana käyttäjän hallinnoimiin resursseihin tarjoajan palvelussa. Pääsyoikeuspoletti on voimassa ainoastaan niihin resursseihin, joihin kuluttajapalvelu pyysi valtuuksia hankkimisvaiheessa. Poletti lähetetään joko HTTP Authorization -otsakkeen tai URL:n \emph{query string} -parametrina.

  4. \textbf{Virkistyspoletti}
  Pääsyoikeuspoletilla on rajoitettu elinaika. Jos kuluttajapalvelu tarvitsee pitkäaikaisen pääsyn resurssiin, tarjoajalta noudetaan pääsyoikeuspolettia vastaan virkistyspoletti. Tarkoituksena on tarjota lyhytikäinen poletti, mutta pitkäikäinen auktorisointi. Kuluttajapalvelu voi hakea uuden virkistyspoletin samalle pääsyoikeuspoletille, jolloin käyttäjää ei tarvitse vaivata auktorisointipyynnön kanssa. Käyttäjä voi evätä pääsyoikeuspoletin, jolloin sitä vastaan ei enää myönnetä uusia virkistyspoletteja.    todo: selitä tarkemmin, miksei ennemmin vain käytä aina pääsyoikeuspolettia.



  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/google_id_and_user_consent.jpg}
    \caption{Käyttäjän suostusmusvaihe Googlen toteuttamana. Käyttäjällä on kaksi rinnakkaista identiteettiä samalla identiteetintarjoajalla. Käyttäjäagentilla on sessio voimassa kummallekin identiteetille, joten Google ei kysy lainkaan salasanaa vaan antaa loppukäyttäjän valita, kummalta identiteetiltä pääsyoikeuslupa kysytään.}
    \label{fig:google_id_and_user_consent}
  \end{figure}

  % subsubsection oauth_käytännössä (end)


  Soundcloud OAuth authorization flow diagram % http://developers.soundcloud.com/docs/api/authentication#authorization-code-flow

  Twitter OAuth flow diagram
  % https://dev.twitter.com/docs/auth/oauth

  Kerro miksi hueniverse on mainio lähde; blogia pitää yksi oauth-speksin kehittäjistä

  % auktorisointiluvan kysyminen mobiilissa.
  %
  % Onko OAuth 2.0 sama REST-palveluille kuin WS-Trust and WS-Security for SOAP -palveluille? (https://www.pingidentity.com/resource-center/oauth-essentials.cfm)

  Kaaviokuva / sanallinen dialogi autentikaatiosta ennen oauth1.0, oauth2.0, palvelin-palvelin
  ks. Internet-Scale Identity Systems: An Overview and Comparison

  Oauth-identiteetti on tiukasti kytketty tiettyyn palveluntarjoajaan (esim. Facebook).
  Ei ole käyttäjäkeskeinen: Käytettävän palvelun (identity consumer) on tuettava tiettyä palvelua esim tarjoamalla siihen liittyvä kuvake.
  ''Before initiating the protocol, the client registers with the authorization server. The means through which the client registers with the authorization
  server are beyond the scope of this specification, but typically involve end-user interaction with an HTML registration form.'' (viite: ''client registration'' \cite{ietf_oauth2})

  Mahdollistaa ennakkoon rekisteröitymättömät asiakkaat: kpl 2.4 ''This specification does not exclude the use of unregistered clients. However, the use with
  such clients is beyond the scope of this specification,...''
  3.1.2.2 registration requirements:
    Public ja Confidential clients utilizing the implicit grant type MUST register prior to using the authorization endpoint.
  On olemassa ietf-draft (work in progress), joka mahdollistaisi automaattisen discoveryn eli rekisteröitymättömät clientit (draft-hardjono-oauth-dynreg-01) % http://tools.ietf.org/html/draft-hardjono-oauth-dynreg-01

  Facebook OAuth dialogs: https://developers.facebook.com/docs/reference/dialogs/oauth/

  OAuth mahdollistaa http basic autentikoinnin (kpl 2.3.1) ennen auktorisointia.
  Draft vaatii HTTPS:n ja brute-force suojauksen:
    ''The authorization server MUST require the use of a transport-layer
     security mechanism when sending requests to the token endpoint, as
     requests using this authentication method result in the transmission
     of clear-text credentials.

     Since this client authentication method involves a password, the
     authorization server MUST protect any endpoint utilizing it against
     brute force attacks.''

  Vaatii aina autentikoitumisen (3.2.1. Client Authentication) tietyissä tapauksissa.

  Tietomurrosta toipuminen (3.2.1):
  ''Changing a single set of client credentials is significantly faster than revoking an entire set of refresh tokens.''
  ''Rotation of an entire set of refresh tokens can be challenging, while rotation of a single set of client credentials is significantly easier.''

  9. Native Authentication:
  ''When choosing between an external or embedded user-agent, developers should consider: [..]''

  10. Client Authentication
  Hyvä kappale eri tietoturvanäkökulmista ja uhkakuvista.
  OAuth ja MITM:
  - 10.6.  Authorization Code Redirection URI Manipulation
  - 10.9.  Endpoints Authenticity
  - 10.11.  Phishing Attacks


  OAuth draft kpl 2.1:
  OAuth Client Types: confindential/public
  OAuth Client Profiles: Web Application, user-agent-based application, native application

  Endpointit: kpl3.1
   The authorization endpoint is used to interact with the resource
      owner and obtain an authorization grant.  The authorization server
      MUST first verify the identity of the resource owner.
   Autentikointimenetelmään ei ota kantaa.
   Edellytetään HTTPS:ää (''The authorization server MUST support TLS 1.0 ([RFC2246]), SHOULD support TLS 1.2 ([RFC5246]) and its future'')
   ks. myös 3.1.2.1 HTTPS
  http://tools.ietf.org/html/draft-ietf-oauth-v2-22

  http://tools.ietf.org/html/draft-ietf-oauth-v2-threatmodel-01

  http://hueniverse.com/2010/05/introducing-oauth-2-0/
  ''OAuth is a security protocol that enables users to grant third-party access to their web resources without sharing their passwords.''
  ''OAuth includes two main parts: obtaining a token by asking the user to grant access, and using tokens to access protected resources. The methods for obtaining an access token are called flows.''
  ''Bearer tokens: OAuth 2.0 provides a cryptography-free option for authentication which is based on existing cookie authentication architecture. Instead of sending signed requests using HMAC and token secrets, the token itself is used as a secret sent over HTTPS. This allows making API calls using cURL and other simple scripting tools without having to canonicalize the request and sign it.''
  ''Short-lived tokens with Long-lived authorizations: Instead of issuing a long lasting token (typically good for a year or unlimited lifetime), the server can issues a short-lived access token and a long lived refresh token. This allows clienta to obtain a new access token without having to involve the user again, but keeps access tokens limited. This feature was adopted from Yahoo!’s BBAuth protocol and later its OAuth 1.0 Session Extension.''

  ''This has been a sore point from the beginning with people arguing whether OAuth is an authentication protocol or an authorization protocol, with the word ‘delegation’ being used as a compromise. The truth is, OAuth contains both. The redirection-based flow is authorization (with user authentication left intentionally out of scope), and the signature flow is authentication. By separating the two, OAuth becomes more modular and easier to understand.'' http://hueniverse.com/2009/11/planning-for-oauth-2-0/

  ''Over the past few weeks, we determined that OAuth is now a mature standard with broad participation across the industry. In addition, we have been working with Symantec to identify issues in our authentication flow to ensure that they are more secure. This has led us to conclude that migrating to OAuth \& HTTPs now is in the best interest of our users and developers. (11.5.2011, https://developers.facebook.com/blog/post/497/)''


  \subsubsection{OAuth-tokenit} % (fold)
  \label{ssub:oauth_tokenit}

  Tässä selitetään kansantajuisesti, mikä on refresh token ja access token.
  Ja mikä on bearer token type, miten online/offline access erotellaan.

  selitetään \verb!client_id!, \verb!response_type!, \verb!client_secret!, \verb!redirect_uri!, \verb!scope!, \verb!access_type!, \verb!approval_prompt!

  offline access edellyttää on refresh-tokenin, jolla saa rajattomasti lisää uusia tokeneita. access token edellyttää että käyttäjä on läsnä, eli että user consent voi toteutua. access token vain jonkin aikaa voimassa, refresh tokenilla saa uuden access tokenin jos ensimmäinen access token vielä voimassa (eli käyttäjä ei ole evännyt pääsyä). jos ei offline niin silloin ei refresh tokeniakaan.


  % subsubsection oauth_tokenit (end)

  \subsubsection{OAuth-flowt} % (fold)
  \label{ssub:oauth_flowt}

  1. User-Agent Flow: Käyttäjäagentilla asioiville asiakkaille (webselaimet)

  2. Web Server Flow: Osana web-palvelua oleville asiakkaille, palvelin--palvelin-yhteydet HTTP:llä. Aiempaan OAuth 1.0:aan verrattuna yksinkertaisestti flow.

  3. Device Flow: Rajoitettujen päätelaitteiden asiakkaille, kun loppukäyttäjällä on sovelluksesta riippumaton pääsy web-selaimeen toisella päätelaitteella tai tietokoneella.

  4. Client Password Flow (rfc kpl 2.3.1): Loppukäyttäjä luottaa asiakkaaseen ja tarjoaa sille salasanansa. Asiakas antaa salasanan eteenpäin identiteetintarjoajalle speksin mukaan ensisijaisesti HTTP Basic Authilla, jolloin \verb!client_id! on OAuth-käyttäjätunnus ja \verb!client_secret! OAuth-salasana. Speksi ei suosittele näiden tietojen välittämistä HTTP-otsakkeissa ja kieltää niiden välittämisen osana URI:a.

  Asiakkaan ei ole suositeltavaa tallettaa loppukäyttäjän salasanaa itselleen vaan vaihtaa se pääsyoikeuspolettiin. Tämä flow on soveltuu vain tilanteeseen, jossa loppukäyttäjällä ja asiakkaalla on luottamussuhde. Ks. kohta jossa kerrotaan Twitter ja xAuth. RFC:n mukaan HTTPS-yhteys ja on välttämätön käytettäessä Client Password -flowta.

  5. Client Credentials Flow: Asiakas käyttää \emph{credentials} hankkiakseen pääsyoikeuspoletin. Ota selvää mikä on 2-legged scenario.

  6. Assertion Flow: Asiakas esittää assertion (kuten SAML-assertio), jota vastaan auktorisointipalvelin tarjoaa pääsyoikeuspoletin.

  Lähde: http://hueniverse.com/2010/05/introducing-oauth-2-0/



  http://code.google.com/apis/accounts/docs/OAuth2WebServer.html

  https://developers.facebook.com/docs/authentication/


  % subsubsection oauth_flowt (end)


  % http://fireeagle.yahoo.net/developer/documentation/using_oauth
  %
  % http://developers.soundcloud.com/docs/api/authentication#refreshing
  % Once an access_token is expired you can use the refresh_token to obtain a new one:
  %
  % $ curl "https://api.soundcloud.com/oauth2/token" \
  %            -d 'client_id=YOUR_CLIENT_ID' \
  %            -d 'client_secret=YOUR_CLIENT_SECRET' \
  %            -d 'grant_type=refresh_token' \
  %            -d 'refresh_token=04u7h-r3fr35h-70k3n'
  % {
  %   "access_token": "04u7h-4cc355-70k3n-2",
  %   "expires_in": 3600,
  %   "scope": null,
  %   "refresh_token": "04u7h-r3fr35h-70k3n-2"
  % }

  % Using a Refresh Token
  % http://code.google.com/apis/accounts/docs/OAuth2ForDevices.html
  %
  % POST /o/oauth2/token HTTP/1.1
  % Host: accounts.google.com
  % Content-Type: application/x-www-form-urlencoded
  %
  % client_id=812741506391-h38jh0j4fv0ce1krdkiq0hfvt6n5amrf.apps.googleusercontent.com&
  % client_secret={clientSecret}&
  % code=4/L9fTtLrhY96442SEuf1Rl3KLFg3y&
  % grant_type=http://oauth.net/grant_type/device/1.0
  %
  % If the user has not yet approved the request, the response will appear as follows:
  % {
  %   "error" : "authorization_pending"
  % }
  % Your application should repeat these requests at the rate that does not exceed the value of interval field. If your application polls too quickly, then the response will appear as follows:
  % {
  %   "error" : "slow_down"
  % }
  % Once the user logs in and grants your application access to a Google API, the next polling request will result in an access and refresh token (shown below).
  % {
  %   "access_token" : "ya29.AHES6ZSuY8f6WFLswSv0HELP2J4cCvFSj-8GiZM0Pr6cgXU",
  %   "token_type" : "Bearer",
  %   "expires_in" : 3600,
  %   "refresh_token" : "1/551G1yXUqgkDGnkfFk6ZbjMLMDIMxo3JFc8lY8CAR-Q"
  % }
  % Upon receipt of this response, your application may use the access token in Google API requests. Access tokens have a limited lifetime. If your application needs access to an API over a long period of time, then it can use the refresh token to obtain a new access token (see Using a refresh token). If your application needs this type of access, then it should store the refresh token for later use.
  %
  % Access tokens expire. An API will indicate that an access token has expired when it returns a 401 status code. To obtain a new access token, make a request to the token endpoint and include the client_id, client_secret, refresh_token, and grant_type parameters (shown below).
  % POST /o/oauth2/token HTTP/1.1
  % Host: accounts.google.com
  % Content-Type: application/x-www-form-urlencoded
  %
  % client_id=812741506391-h38jh0j4fv0ce1krdkiq0hfvt6n5amrf.apps.googleusercontent.com&
  % client_secret={clientSecret}&
  % refresh_token=1/551G1yXUqgkDGnkfFk6ZbjMLMDIMxo3JFc8lY8CAR-Q&
  % grant_type=refresh_token

  \subsubsection{Autentikoituminen OAuth-protokollalla} % (fold)
  \label{ssub:autentikoituminen_oauth_protokollalla}

  Identiteetinkuluttaja on rekisteröitynyt etukäteen identiteetintarjoajan asiakkaaksi~\cite{google_oauth2_doc, facebook_oauth2_doc}. Rekisteröintiprosessissa kuluttajalle on määritetty tunnisteena \verb!client_id!, salaisuutena \verb!client_secret! sekä yksi tai useampi loppukäyttäjän takaisin kuluttajapalveluun palauttava \verb!redirect_uri!. Kuluttajapalvelun tavoitteena on saada tarjoajapalvelulta \verb!access_token!, jonka tarjoaja myöntää, jos se hyväksyy loppukäyttäjän autentikoitumisen.

  Prosessi alkaa, kun kuluttaja uudelleenohjaa käyttäjäagentin tarjoajapalvelun URL-osoitteeseen, jonka parametreiksi kuluttaja liittää tunnistetietonsa. Tarjoajapalvelu ottaa käyttäjäagentin vastaan ja suorittaa käyttäjän tunnistamisen. OAuth ei ota kantaa autentikoinnin yksityikohtiin~\cite{ietf_oauth2}, joten tarjoaja voi esimerkiksi soveltaa kaksivaiheista autentikointia ja antaa käyttäjän valita, minkä identiteettinsä hän haluaa ottaa käyttöön ennen käyttäjän suostumisvaihetta (kuva~\ref{fig:google_id_and_user_consent}).

  Identiteetintarjoajalle autentikoitumisen jälkeen tarjoaja kysyy käyttäjän suostumuksen kuluttajapalvelun pyytämien tietojen välittämiseksi eteenpäin. Jos käyttäjä suostuu, tarjoaja lyö leimansa vastaukseen, jonka käyttäjäagentti välittää \verb!redirect_uri!:n kautta kuluttajapalveluun. Kun identiteetinkuluttaja on palvelinpään sovellus, tarjoajan vastaus on auktorisointikoodi (\emph{authorization code}). Auktorisointikoodi on lyhyen aikaa voimassa oleva väliaikainen tunniste, jota vastaan kuluttajapalvelu seuraavaksi lunastaa valtakirjan loppukäyttäjän resursseihin eli \verb!access_token!- ja (mahdollisesti) \verb!refresh_token!-poletit.

  Kuluttaja tarvitsee auktorisointikoodia ainoastaan silloin, kun käyttäjältä kysytään suostumusta. Käyttäjän suostumus tarvitaan silloin, kun kuluttajalla ei ole \verb!access_token!-valtakirjaa tai kun aiemmin myönnetty \verb!access_token! on vanhentunut. \verb!Access_token! on aina rajallisen ajan voimassa ja edellyttää käyttäjän läsnäoloa (todo selitä paremmin) ollakseen käyttökelpoinen. Jos kuluttaja tarvitsee käyttäjästä riippumattoman pääsyn tarjoajan resursseihin, kuluttajan on pyydettävä käyttäjän suostumusvaiheessa \verb!offline access!-lupaa. Tällöin tarjoaja antaa auktorisointikoodin lunastamisen yhteydessä \verb!acces_token!-poletin lisäksi myös \verb!refresh_token!-poletin.

  Kuluttaja voi olla myös asiakaspään sovellus kuten esimerkiksi käyttäjäagentissa suoritettava Javascript-ohjelma. Tällöin tarjoaja palauttaa auktorisointikoodin sijasta suoraan \verb!access_code!:n. Tutkielman puitteissa rajaudumme kuitenkin identiteetinkuluttajiin, jotka ovat palvelinpään sovelluksia kuten MOOC-järjestelmä.

  todo bookmarkit
  todo kuva multifactor auth jossa google login + authenticator sovellus

  % subsubsection autentikoituminen_oauth_protokollalla (end)


  % subsection oauth (end)





  \subsection{Tekniikoiden soveltuvuus} % (fold)
  \label{sub:tekniikoiden_yhtäläisyydet}

  Sen jälkeen kun eri tekniikat on selitetty, yhteenvetokappaleeseen taulukko jossa parilla lauseella selitetään jokainen.
  + Voi olla toinenkin taulukko, jossa esim. front channel ja back channel jokaisen protokollan osalta.
  + Trust Model: RP/SP initiated; IDP initieated %; (esim definition of trust: "A reasonable expectation of confidence in an actor’s behavior")
  + Registration / Discovery % ("Discovery is similar to a Web search for an identity."; "Discovery can be preceded by a registration step: a step by which IDPs register themselves as providing a particular identity service for a given user. Such a registry could be located on the client or on a network endpoint.")

    % http://stackoverflow.com/questions/7699200/what-is-the-difference-between-openid-and-saml
    % SAML2 supports single sign-out - but OpenID does not
    % SAML2 service providers are coupled with the SAML2 Identity Providers, but OpenID relying parties are not coupled with OpenID Providers. OpenID has a discovery protocol which dynamically discovers the corresponding OpenID Provider, once an OpenID is given.
    % With SAML2, the user is coupled to the SAML2 IdP - your SAML2 identifier is only valid for the SAML2 IdP who issued it. But with OpenID, you own your identifier and you can map it to any OpenID Provider you wish.
    % SAML2 has different bindings while the only binding OpenID has is HTTP
    %
    %


    % TODO: Tää on huono kuva.
    %
    % \begin{figure}
    %   \centering
    %   \includegraphics[width=0.9\textwidth]{images/kertakirkautumistekniikat_venn.jpg}
    %   \caption{Yleiskuva kertakirjautumistekniikoiden yhtenäisyyksistä. todo kuva piirrettävä selkeämmäksi tai poistettava}
    %   \label{fig:yleiskuva_sso_yhtenaisyyksista}
    % \end{figure}

    Sen jälkeen kun eri tekniikat on selitetty, yhteenvetokappaleeseen taulukko jossa parilla lauseella selitetään jokainen.
    + Voi olla toinenkin taulukko, jossa esim. front channel ja back channel jokaisen protokollan osalta.
    + Trust Model: RP/SP initiated; IDP initieated; (esim definition of trust: A reasonable expectation of confidence in an actor’s behavior)
    + Registration / Discovery (Discovery is similar to a Web search for an identity.; Discovery can be preceded by a registration step: a step by which IDPs register themselves as providing a particular identity service for a given user. Such a registry could be located on the client or on a network endpoint.)

  % subsection tekniikoiden_yhtäläisyydet (end)


% section Kertakirjautumisstandardit (end)



%%%%%%%%%%%%%%%%%%%%

\section{MOOC-palvelun autentikointiratkaisun arkkitehtuuri} % (fold)
\label{sec:mooc_palvelun_autentikointiratkaisun_arkkitehtuuri}

MOOC-järjestelmän toteutuksessa sovelletaan sekä käyttäjäkeskeisen että federoidun identiteetin periaatetta. Käyttäjäkeskeinen identiteetti toteutetaan tarjoamalla tunnistautumisvaihtoehdoiksi OpenID sekä vapaavalintaisella että esivalitulla identiteetintarjoajalla. OpenID:n vapaavalintaisen identiteetintarjoajan ansiosta avulla kuka tahansa voi rekisteröityä. Esivalittuna identiteetintarjoajana toteutetaan yksinkertaisuuden vuoksi ainoastaan Google. Federoitu identiteetti toteutuu Helsingin yliopiston opiskelijoille mahdollisuutena autentikoitua Helsingin yliopiston käyttäjätunnuksella käyttäen SAML-standardia.

Tässä tapauksessa OAuth luokittuu käyttäjäkeskeisen ja federoidun identiteetin välille. OAuth-protokolla ei itsessään toteuta käyttäjäkeskeisen identiteetin periaatetta, mutta OAuthilla voidaan tuoda MOOC-palveluun yksi identiteetintarjoaja lisää. Käyttäjän kannalta ei ole merkitystä protokollalla vaan mahdollisuudella itse valita oma identiteetintarjoajansa. Siksi MOOC-järjestelmään tuodaan kolmantena vaihtoehtona OAuth-autentikoituminen Facebook-palveluun.

MOOC-palvelun kannalta identiteetin myöntäneellä organisaatiolla ei ole merkitystä. Autentikoinnin vaatimuksena on varmistaa, että vain ja ainoastaan identiteetin oikea haltija pystyy osoittamaan identiteettiin liittyvän tunnisteen itselleen. Tunniste on OpenID:n tapauksessa OpenID URL, OAuthin tapauksessa XXX (johon \verb#acecss_token# kytketään) ja SAMLin tapauksessa XXX.

Yllä mainittujen lisäksi MOOC voisi myös itse toimia identiteetintarjoajana. Tämä toteutettaisiin SOA-arkkitehtuurimallin mukaisesti itsenäisenä palvelunaan käyttäen joko OpenID tai OAuth -standardia. Erona nykytilanteeseen olisi identiteetintarjoajan erottaminen MOOC-ydinpalvelusta (loosely coupled -periaate). Ratkaisun positiivisena puolena olisi, että käyttäjille voitaisiin tarjota sisäänkirjautuminen ilman, että käyttäjältä edellytetään esiasetettujen identiteetintarjoajien tarjoamaa tiliä. Tällöin käyttäjä voisi rekisteröityä suoraan MOOC-palvelussa, kun nyt Helsingin yliopiston ulkopuolisen käyttän on ensin luotava tili OpenID-palveluntarjoajalle tai Facebookiin. Oma MOOC-identiteetintarjoaja tuottaisi kuitenkin lisätyötä ylläpidon ja hallinnon muodossa riippumatta siitä, ylläpidetäänkö käyttäjätietokantaa itse vai delegoidaanko se Helsingin yliopiston käyttäjärekisteriin. Ratkaisun yksinkertaistamiseksi omaa MOOC-identiteetintarjoajaa ei tämän tutkielman puitteissa käsitellä.

Tutkielma esittää suunnitelman, jossa kertakirjautuminen ei olisi mahdollinen pelkästään yhdellä yhteentoimivuuden standardilla. MOOC-palvelun toteutuksessa rinnakkaiset standardit -- OpenID, OAuth, ja SAML -- tukevat toinen toisiaan eivätkä varsinaisesti kilpaile keskenään.

  \subsection{Autentikointi Helsingin yliopiston identiteetillä} % (fold)
  \label{sub:autentikointi_helsingin_yliopiston_verkkoympäristössä}

  Helsingin yliopistolla (HY) on virallinen hallinnollinen päätös keskittää kaikki autentikointi Active Directory (AD) -palveluun (todo tarvitaanko lähde?).
  Tietojenkäsittelytieteen laitoksella (TKTL) on oma AD-palvelu ja lisäksi lukuisa määrä erilaisia ja -tasoisia autentikointipalveluja.
  Sisäinen toteutus voisi olla henkilökohtaiset Kerberos-sertifikaatit (todo termi), mutta sellainen ratkaisu ei olisi yhteensopiva yliopiston AD-päätöksen kanssa, eikä se olisi siksi toteuttamiskelpoinen.

  TKTL:n ensisijainen käyttäjätietojen lähde on Helsingin yliopiston tietotekniikkaosaston käyttäjärekisteri, josta käyttäjätiedot kopioidaan eräajona TKTL:n omien autentikointipalvelujen käytettäviin. Esimerkiksi laitoksen ilmoittautumisjärjestelmä autentikoi TKTL:n LDAP-palveluun, johon käyttäjätiedot on kopioitu eräajona HY:n ensisijaisesta käyttäjärekisteristä. LDAP-sisältää käyttäjän henkilötietojen lisäksi myös hashatun (todo termi) salasanan, jota vastaan autentikoniti suoritetaan. Rinnakkaisia perinnejärjestelmiä on syntynyt ajan kanssa ja niiden integroiminen yhdeksi yhteiseksi järjestelmäksi vaatiis paljon työtä.

  Autentikointinsa puolesta MOOC-järjestelmän ei kannata ylläpitää ongelmaa, vaan olla ennemmin osa sen ratkaisua. Siksi tämän tutkielman puitteissa noudatetaan HY:n virallista päätöstä ja valitaan Active Directory yliopiston sisäisen käyttäjätunnuksen autentikointilähteeksi. Akateemisessa ympäristössä vapaus on perusarvo, minkä vuoksi järjestelmä tukee käyttäjäkeskeistä identiteettiä eli mahdollistaa vapaavalintaisen OpenID-identiteetintarjoajan käyttämisen. Käyttäjäystävällisyyden vuoksi tarjotaan myös kaksi esiasetettua identintarjoajaa: Google (OpenID) ja Facebook (OAuth).

  Esitellään arkkitehtuuritasolla suunnitelma, että yliopistolla on oma idp, jolla on ainoa SAML-yhteys AD:hen. Tällöin AD:hen ei tartte puhkaista reikiä, vaan yliopiston idp tarjoaa siihen OAuth (ja \emph{tarvittaessa} SAML-rajapinnan). Ylioipston oma idp voi tukea myös OpenID:tä, jolloin yliopiston tunnus toimisi OpenID:nä maailmalle. Tällöin Kurhilan kurssipalautejärjestelmät sun muut (kymmenet eri) yliopiston palvelut eivät koskaan yhdistä suoraan käyttäjärekisteriin. Tällöin käyttäjäreskiterin toteutus voidaan vaihtaa taustalla ilman että rajapinta muuttuu. Ohtuprojektit ja muut pottikset eivät myöskään saa suoraa yhteyttä käyttäjärekisterin palveluun mikä on plussaa. OAuth toimii facebookin mittakaavassa (eikä idp:n tarvi luottaa idc:hen) joten pitäisi esittää erittäin hyvät syyt, miksei hy-oauth-idp:tä voisi tehdä ja tarjota siihen avointa rajapintaa (verrattuna nykytilanteeseen jossa omat käyttäjälähteet ja palvelut käsittelee salasanoja itse).

  % subsection autentikointi_helsingin_yliopiston_verkkoympäristössä (end)


  \subsection{Autentikoituminen Helsingin yliopiston identiteetillä} % (fold)
  \label{sub:autentikoituminen_helsingin_yliopiston_käyttäjärekisteriin}
  % * Helsingin yliopistolla on Active Directoryssä 40.000 käyttäjää.
  % Kaikki hlökunta + opiskelijat.
  %
  % * HY:llä perustaa oman julkisen identiteetintarjoajapalvelun (idp).
  %
  % * Tämä HY:n idp on ****AINOA**** palvelu, joka juttelee suoraan Active
  % Directoryn kanssa.
  %
  % * IDP tarjoaa OAuth (ja lisäksi vaikka esim OpenID ja SAML)
  % -rajapinnan, jolla Kurhilan kurssipalvelu tai Luukkaisen MOOC-kurssi,
  % TKTL:n ilmo jne voivat autentikoitua Helsingin ylioipston
  % käyttäjärekisteriin.
  %
  % * Tällöin arkaluontoista Active Directoryä ei tartte koskaan pistää
  % julkiseksi, vaan välissä on yksi abstraktiokerros, jonka avulla Uuden
  % Internetin Ihanalla OAuthilla pystyy autentikoimaan Helsingin
  % yliopiston käyttäjärekisteriin.
  %
  % OAuth tukee SAML-assertioita, eli ehkä(?????) sillä vois myös
  % autentikoitua suoraan Active Directoryyn SAMLilla, ei kyllä tästä
  % mitään hajua.

  % subsection autentikoituminen_helsingin_yliopiston_käyttäjärekisteriin (end)



  \subsection{Autentikoituminen Google- ja Facebook-identiteetillä} % (fold)
  \label{sub:autentikoituminen_facebook}
  Tässä kerrotaan kuinka Facebook-autentikoinnilla pääsee MOOC-palveluun.

  Päälähteenä Facebookin kehittäjädokumentaatio:
  \\ \verb!https://developers.facebook.com/docs/authentication/!


  % - In order to log the user into your site, three things need to happen. First, Facebook needs to authenticate the user. This ensures that the user is who they say they are. Second, Facebook needs to authenticate your website. This ensures that the user is giving their information to your site and not someone else. Lastly, the user must explicitly authorize your website to access their information. This ensures that the user knows exactly what data they are disclosing to your site.
  % - auktorisointipäätös käyttäjälle itselleen (ei automaatille)

  Google tarjoaa OpenID 2.0 + OAuth 1.0 -yhdistelmän. Myös itsenäinen OAuth 2.0!  Autentikointi OpenID:llä, auktorisointi OAuthilla. Koska ei tutkita auktorisointia, tässä esitellään vain OpenID.
  % http://code.google.com/apis/accounts/docs/OAuth2.html

  OpenID attribute exchange mahdollistaa käyttäjätietojen välittämisen autentikoinnin yhteydessä. Tällaisia esim sähköpostiosoite tai henkilön koko nimi. Suppea.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/google_openid_diagram.png}
    \caption{Sekvenssikaavio OpenID-autentikoinnista; Googlen suosittelema autentikointiprosessi (todo viite http://code.google.com/apis/accounts/docs/OpenID.html)}
    \label{fig:sekvenssikaavio_google_openid}
  \end{figure}

  % Kuva:
  % 1. The web application asks the end user to log in by offering a set of log-in options, including using their Google account.
  % 2. The user selects the "Sign in with Google" option. See Designing a Login User Interface for more options.
  % 3. The web application sends a "discovery" request to Google to get information on the Google login authentication endpoint.
  % 4. Google returns an XRDS document, which contains the endpoint address.
  % 5. The web application sends a login authentication request to the Google endpoint address.
  % 6. This action redirects the user to a Google Federated Login page, either in the same browser window or in a popup window, and the user is asked to sign in.
  % Once logged in, Google displays a confirmation page (redirect version / popup version) and notifies the user that a third-party application is requesting authentication. The page asks the user to confirm or reject linking their Google account login with the web application login. If the web application is using OpenID+OAuth, the user is then asked to approve access to a specified set of Google services. Both the login and user information sharing must be approved by the user for authentication to continue. The user does not have the option of approving one but not the other.
  % Note: If the user is already logged into their Google account, or has previously approved automatic login for this web application, the login step or the approval step (or both) may be skipped.
  %
  % 7. If the user approves the authentication, Google returns the user to the URL specified in the openid.return_to parameter of the original request. A Google-supplied identifier, which has no relationship to the user's actual Google account name or password, is appended as the query parameter openid.claimed_id. If the request also included attribute exchange, additional user information may be appended. For OpenID+OAuth, an authorized OAuth request token is also returned.
  %
  % 9. The web application uses the Google-supplied identifier to recognize the user and allow access to application features and data. For OpenID+OAuth, the web application uses the request token to continue the OAuth sequence and gain access to the user's Google services.
  % Note: OpenID authentication for Google Apps (hosted) accounts requires an additional discovery step. See OpenID API for Google Apps accounts.

  % Googlen OpenID-päätepiste (\emph{endpoint}) löytyy lähettämällä HTTP \verb#GET# tai \verb#HEAD# -pyyntö osoitteeseen \verb#https://www.google.com/accounts/o8/id#. Tämä discovery-pyyntö (todo termi) palauttaa \verb#XRDS#-dokumentin, joka sisältää Googlen OpenID-identiteetintarjoajan päätepisteen URL:n. Identiteetintarjoajan URL ilmaistaan vastauksessa seuraavasti~\cite{google_openid_dev_docs}:
  %
  % \begin{verbatim}
  %   <Service priority="0">
  %   <Type>http://specs.openid.net/auth/2.0/server</Type>
  %   <URI>{Googlen OpenID-päätepisteen URL}</URI>
  %   </Service>
  % \end{verbatim}

  % lue http://code.google.com/googleapps/domain/sso/openid_reference_implementation.html

  % subsection autentikoituminen_facebook (end)

  \subsection{Autentikoituminen käyttäjäkeskeisellä identiteetillä} % (fold)
  \label{sub:autentikoituminen_käyttäjäkeskeisellä_identiteetillä}

  Tässä esitellään OpenID-toteutus.

  % subsection autentikoituminen_käyttäjäkeskeisellä_identiteetillä (end)

  \subsection{Uuden käyttäjän rekisteröityminen} % (fold)
  \label{sub:uuden_käyttäjän_rekisteröityminen}

  Edellä käsiteltiin ainoastaan sisäänkirjautumista. Samoin kuin induktiossa tarvitaan alkuaskel, identiteetti täytyy rekisteröidä ennen kuin sitä vastaavaa käyttäjätunnusta voidaan käyttää sisäänkirjautumiseen.

  Kuka määrittelee facebookille idc:n ''registration url:n'':n ? Voitaisiin myös ottaa vain facebook uid ja tehdä auktorisointipyyntö käyttäjän facebook-tietoihin. Koska monta idp-vaihtoehtoa, suoritetaan idp-rekisteröinnin jälkeen oma rekisteröinti.

  Miten Google?

  Google tarjoaa sekä OpenID että OAuth -sisäänkirjautumisen. Kumpaa käytetään?

  Selitä tähän kuva~\ref{fig:registration_with_facebook} Facebookin site registration flow \url{https://developers.facebook.com/docs/user_registration/flows/}

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/facebook_user_registretion.png}
    \caption{Uuden käyttäjän rekisteröityminen MOOC-palveluun. TODO: piirrä tän pohjalta uusi kuva, jossa facebookin tilalla idp (hy/google/fb) ja jossa site-specific credentials poistettu. viite }
    \label{fig:registration_with_facebook}
  \end{figure}

  % https://developers.facebook.com/docs/user_registration/flows/

  % subsection uuden_käyttäjän_rekisteröityminen (end)

  \subsection{Uloskirjautuminen ja kertauloskirjautuminen} % (fold)
  \label{sub:kertauloskirjautuminen}
  Kerrotaan lyhyesti kertauloskirjautumisen idea ja toteutusperiaate. Miksi hyvä juttu.

  MOOC-sessio nullataan kun uloskirjautuu moocista. IDP-sessio jää voimaan. Jos palvelusta logout, niin logout myös idp:ltä. Koska jos käyttää julkiselta koneelta, niin muuten jäisi huomaamatta sessio auki idp:hen! Vastaavasti, jos logout idp:ltä, niin idc:n sessio ei enää voimassa. IDC:llä user-consent-vastuu, kun ei refresh-tokenia. HUOM! OpenID v2.0:ssa tämä ei toteudu!

  Webissä palveluja joihin kirjaudutaan ainoastaan fb-tunnareilla. Tällaisesta palvelusta logout kirjaa käyttäjän ulos myös facebookista. uloskirjautuminen voi tulla yllätyksenä (minulle tuli kun kokeilin, urheilusaitti se jonka nimeä en koskaan muista).

  % subsection kerta (end)



  \subsection{Suunnitelman arviointi} % (fold)
  \label{sub:suunnitelman_arviointi}

  Tähän kuva MOOC-palvelun sisäänkirjautumissivusta.

  Vastataan alkukappaleessa esitettyihin kysymyksiin.

  Yksityisyys? % http://www.google.com/policies/

  Kuka varastoi mitäkin? Entistä suurempi käyttäjäkunta vähemmällä ylläpidolla.

  Onko OAuth1:n salaisuuden talletusongelmat edelleen relevantteja OAuth2:n desktop/mobiilikäytössä?
  Salaisuuden varastointi on desktop/mobiiliympäristössä. Web-palvelussa salaisuus voidaan varastoida esim. tietokantaan. Mutta työpöytäkäytössä yhden tallettaman salaisuuden voi pölliä toinen ohjelma: tällöin jälkimmäinen voi käyttää palvelua edelliselle myönnetyillä oikeuksilla. Tässä tutkielmassa rajaudutaan web-palveluihin. Twitter ja Yammer ratkaisseet ongelman kysymällä käyttäjältä pin-koodia oikeuksien myöntämisen yhteydessä (miten toimii, onko kertakäyttöinen?) % http://stackoverflow.com/questions/1934187/oauth-secrets-in-mobile-apps

  Skaalautuuko, mitkä ovat uudet pullonkaulat?

  Kuinka luotettavia tunnisteet ovat? Federoitu vs käyttäjäkeskeinen. Keskitetty + user centric = monta sso-identiteettiä.

  Vastaa tähän kaikkiin kriteereihin, jotka nostetaan esiin kakkosluvussa.

  Identiteetinkuluttaja voi vaatia OpenID idp:ltä PAPE-laajennoksen avulla tietyn turvallisuustason, esim. 2-factor autentikoinnin.

  Kertauloskirjautuminen: jos logout palvelusta niin logout myös idp:stä. Muuten jää huomaamatta sessio auki! (esim julkinen työasema)

  Käyttäjän nähtävillä selainkonteksti, ei kysytä salasanaa mooc-palvelussa. tarviiko käyttäjän ymmärtää? jos käyttäjä lähtökohtaisesti on valmis syöttämään salasanansa sinne, missä ikinä kysytäänkin.

  Haasteena yksityisyys, turvallisuus ja lainsäädäntö. Joissain tapauksissa tietoja ei saa säilyttää kotimaan rajojen ulkopuolella, joskus tietoja saa säilyttää ainoastaan oman organisaation omistamassa verkkoympäristössä.

  Monesti haasteet ovat mahdollisuuksia valepuvussa.

  Keskitetty vs. munat samassa korissa. Painotetaan: Jos MOOC haksoroidaan, salasanat eivät päädy vääriin käsiin. Google/FB panostavat käyttäjien tietoturvaan (eri asia kuin tietosuoja), kosak niiden bisnes edellyttää luottamusta turvallisuuteen. Moocin ylläpito ei pysty samaan, todennäköisempää että jokin tietoturvareikä jää paikkaamatta MOOCissa kuin Googlessa. Verrataan uudelleen Gawker-tietomurto vs twitter-salasanojen väärinkäyttöaalto.

  Ylläpito- ja kehitystyötä säästyy ydintoimintaan eli opetukseen ja kurssien kehittämiseen. Ei lisää omaa softaa ylläpidettäväksi (idp) eikä varsinkaan omaa laitteistoa (idp:n oma palvelin) fyysisenä tai virtualisoituna.

  Tietomurrosta toipuminen: mitä credentiaaleja/tokeneita eri tekniikoissa pitää vaihtaa jotta väärä pääsy estyy?

  Rage toimii apurahalla. Apuraha opetuksen, ei ohjelmistojen kehittämiseen.

  % subsection suunnitelman_arviointi (end)

  \subsection{Jatkokehitysideoita} % (fold)
  \label{sub:jatkokehitysideoita}

  \subsubsection{Pääsyoikeuksien myöntäminen ohjelmakoodin palauttamiseksi} % (fold)
  \label{ssub:pääsyoikeuksien_myöntäminen_ohjelmakoodin_palauttamiseksi}

  Kurssisuoritus edellyttää tehtävien hyväksyttyä suorittamista. Tehtävien tarkistaminen tarkistaminen on automatisoitu. Ohjelmointitehtävistä annetaan opiskelijoille yksikkötestit, joiden täytyy suorittua hyväksytysti, jotta opiskelijan ohjelmointitehtävä hyväksytään. Opiskelijalla on yksikkötestit käytettävissä omassa kehitysympäristössänsä. Opiskelijan IDE-kehitysohjelmaan on toteutettu erillinen lisäosa (plugin), joka lähettää opiskelijan ohjelmointitehtävien ratkaisut HTTP-rajapinnan kautta MOOC-palveluun. Sen jälkeen MOOC-palvelu suorittaa taustalla yksikkötestit ja kirjaa tehtävät hyväksytyiksi, jos testit menevät läpi.

  Tehtäväpalautusten rajapinta tarvitse pääsyoikeudet. Nykyinen toteutus on HTTP Basic Authilla, jossa opiskelija antaa käyttäjätunnuksensa ja salasanansa IDE-ohjelmistoon. Tämä ei hyvä, koska salasana monessa eri paikassa. Yksinkertainen ratkaisu: MOOC-palvelu luo käyttäjälle API-keyn joka syötetään IDE:hen. Parempi ratkaisu: Sopiva OAuth-flow, jolla auktorisoidaan työpöytäsovellus.

  Tämän tutkielman fokus on käyttäjän autentikoimisessa, joten pääsyoikeuksien myöntäminen jää jatkokehitysideaksi.


  % subsubsection pääsyoikeuksien_myöntäminen_ohjelmakoodin_palauttamiseksi (end)

  \subsubsection{Pääsyoikeuksien myöntäminen ulkopuoliselle palvelulle} % (fold)
  \label{ssub:jatkokehitysideoita_auktorisointi}
  MOOC tarjoaa mahdollisuuden antaa opintosuoritusote lukioon. MOOC hakee suoritusotteen Oodista. Auktorisointiin käytetään OAuthia: luvan antaminen edellyttää että käyttäjä itse sallii MOOC-järjestelmän pääsyn Oodissa oleviin käyttäjätietoihinsa.

  On myös mahdollista tarjota MOOC-suorituksista raportti lukioon siten, että MOOC tukee OAuthia ja tarjoaa ulkoisen rajapinnan tietojen noutamiseksi. Tällöin lukion tietojärjestelmä voi hakea käyttäjän MOOC-suoritukset OAuth-valtuutuksella, joka voi olla joko käyttäjän hyväksyttävä TAI sitten palvelin-palvelin-yhteydelle aina hyväksytty (implisiittinen ja sit se toinen tapa).

  Auktorisointi: Käyttäjän yhteystiedot, profiilikuva jne Facebookista.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/facebook_authorization_contact_info.png}
    \caption{Luvan kysyminen OAuthilla tietojen noutamiseksi Facebookista (todo viite https://developers.facebook.com/blog/post/446)}
    \label{fig:luvan_kysyminen_oauth_fb}
  \end{figure}

  Kun aloitin tekstin kirjoittamisen, Googlen tuki OAuth 2.0 :lle oli ''experimental''. Eräänä päivänä maininta hävisi, vaikkei standardi ole vielä valmis. % 6.2.2012

  OpenID Conncet on samankaltainen kuin OAuth 2.0, ''based on the OAuth 2.0''
  OAuth 1.0a edellytti laajennoksen käyttämistä, jotta sen pystyi yhdistämään OpenID 2.0:aan. OpenID Connectissa OAuth 2.0:n toiminnallisuudet on rakennettu suoraan protokollaan.
  % http://openid.net/connect/
  % Current Status: NWIP → Working Draft → Implementer’s Draft Review Period (Dec.24, 2011-Feb.6, 2012) → Implementer’s Draft Voting (Feb.7-13, 2012)→ Implementer’s Draft (Feb. 14, 2012) → Final Review Period → Final Voting → OIDF Standard



  % Sovella hyvä selitys, myös resurssit: http://developers.soundcloud.com/docs/api/authentication
  % Miksi MOOC resurssipohjainen eikä ws-* ?

  Entäs MOOC Mobiili? % https://dev.twitter.com/docs/auth/mobile-sign-flow

  % Käyttökokemus: http://benward.me/blog/oauth-flow
  % Best practices: http://fireeagle.yahoo.net/developer/documentation/oauth_best_practice

  % subsubsection jatkokehitysideoita_auktorisointi (end)

  \subsubsection{Yliopiston oma identiteetintarjoajapalvelu} % (fold)
  \label{ssub:yliopiston_sähköpostit_pilveen}

    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.9\textwidth]{images/google_saml_workflow_vertical.png}
      \caption{Autentikoituminen Helsingin yliopiston käyttäjärekisterillä Googleen. Tällöin esim. yliopiston sähköpostipalvelu, kalenteri ja dokumentit voitaisiin ulkoistaa julkiseen pilveen. Tällöin Googlea voisi käyttää OpenID-proxynä eli autentikoitua Helsingin yliopiston käyttäjätunnuksella mihin tahansa verkkopalveluun, joka tukee OpenID:tä.}
      \label{fig:hy_julkiseen_pilveen}
    \end{figure}

    Yliopiston palvelut julkiseen pilveen, ks kuva~\ref{fig:hy_julkiseen_pilveen}
    todo viite \url{http://code.google.com/googleapps/domain/sso/saml_reference_implementation.html}

  % subsubsection yliopiston_sähköpostit_pilveen (end)

  % subsection jatkokehitysideoita (end)

% section mooc_palvelun_autentikointiratkaisun_arkkitehtuuri (end)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Yhteenveto} % (fold)
\label{sec:yhteenveto}

    Gradun tavoite on täyttynyt, jos koodinimi ''Tienaria'' edustava Luukkainen pystyy kertomaan, mitä eroa ja yhteisiä piiretitä on SAMLilla, OAuthilla ja OpenID:llä.

    OpenID:n käytäjäkeskeisyyden perimmäinen idea toteutuisi, jos sitä voisi käyttää kuten iki.fi:n sähköpostiohjausta. Nyt näyttää siltä että OpenID:stä yleistyy ainoastaan hajautettu autentikointi ilman käyttäjäkeskeisyyttä. Tällöin etuja OAuthiin vähden on vaikea sanoa, koska OAuth tarjoaa myös auktorisoinnin. Toivottavasti tuleva OpenID Connect tarjoaa jotain merkittävästi parempaa tai OAuth syrjäyttää OpenID:n kokonaan. Käytännössä: NYt google tarjoaa sekä openid2.0+oauth1.0 että oauth 2.0, jatkossa vain oauth2.0 jos openid syrjäytyy.

% section yhteenveto (end)


\bibliographystyle{tktl}
\bibliography{g}

\lastpage

\end{document}
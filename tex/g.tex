\documentclass[finnish,gradu]{tktltiki}
\usepackage{ae,aecompl}
\usepackage{url}
\usepackage{amsfonts}
\usepackage{color}
\usepackage{graphicx}

% MEMO:
%   Teksti etenee kuin haluaisi hyvän oppikirjan etenevän.
%   Käsitteet määritellään.
%   Kun käsite ekaa kertaa: italics.


\begin{document}

\title{Internet-skaalan identiteetti:
    \\ ''Case-study kuinka OpenID 2.0, OAuth 2.0 ja SAML 2.0 tukevat toisiaan SaaS-palvelun toteutuksessa.''}

\author{Petrus Repo}
\date{\today}
\level{G!}
\maketitle


\onehalfspacing

\level{Graduluonnos}
\faculty{Matemaattis-luonnontieteellinen}
\department{Tietojenkäsittelytieteen laitos}
\subject{Tietojenkäsittelytiede}
\numberofpagesinformation{\numberofpages\ sivua}

\keywords{OpenID, OAuth, SAML, internet, autentikointi, auktorisointi}

\begin{abstract}

  \begin{verbatim}




                                                            ___
                                                         ,o88888
                                                      ,o8888888'
                                ,:o:o:oooo.        ,8O88Pd8888"
                            ,.::.::o:ooooOoOoO. ,oO8O8Pd888'"
                          ,.:.::o:ooOoOoOO8O8OOo.8OOPd8O8O"
                         , ..:.::o:ooOoOOOO8OOOOo.FdO8O8"
                        , ..:.::o:ooOoOO8O888O8O,COCOO"
                       , . ..:.::o:ooOoOOOO8OOOOCOCO"
                        . ..:.::o:ooOoOoOO8O8OCCCC"o
                           . ..:.::o:ooooOoCoCCC"o:o
                           . ..:.::o:o:,cooooCo"oo:o:
                        `   . . ..:.:cocoooo"'o:o:::'
                        .`   . ..::ccccoc"'o:o:o:::'
                       :.:.    ,c:cccc"':.:.:.:.:.'
                     ..:.:"'`::::c:"'..:.:.:.:.:.'
                   ...:.'.:.::::"'    . . . . .'
                  .. . ....:."' `   .  . . ''
                . . . ...."'
                .. . ."'
               .

  \end{verbatim}

\end{abstract}

\setcounter{tocdepth}{3}
\mytableofcontents

\section{Johdanto} % (fold)
\label{sec:johdanto}

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/auth_yleiskuva.jpg}
    \caption{Yleiskuva asioiden välisestä suhteesta}
    \label{fig:yleiskuva}
  \end{figure}

% section johdanto (end)


\section{Web ja SaaS ilmiöinä} % (fold)
\label{sec:web_ja_saas}


  \subsection{HTTP-protokolla} % (fold)
  \label{sub:http_protokolla}

  % rfc 2068, http/1.1
  %
  % Practical information systems require more functionality than simple
  %    retrieval, including search, front-end update, and annotation. HTTP
  %    allows an open-ended set of methods that indicate the purpose of a
  %    request. It builds on the discipline of reference provided by the
  %    Uniform Resource Identifier (URI) [3][20], as a location (URL) [4] or
  %    name (URN) , for indicating the resource to which a method is to be
  %    applied.
  %
  %    HTTP is also used as a generic protocol for communication between
  %      user agents and proxies/gateways to other Internet systems, including
  %      those supported by the SMTP [16], NNTP [13], FTP [18], Gopher [2],
  %      and WAIS [10] protocols. In this way, HTTP allows basic hypermedia
  %      access to resources available from diverse applications.
  %
  % HTTP on request/response-protokolla. Tilaton.
  %
  % URIs in HTTP can be represented in absolute form or relative to some
  %    known base URI, depending upon the context of their use. The two
  %    forms are differentiated by the fact that absolute URIs always begin
  %    with a scheme name followed by a colon.
  %
  % RFC kpl 1.4
  %
  % HTTP 1.1 -pyyntö:
  % \begin{verbatim}
  %   GET /resurssi HTTP/1.1
  %   Host: verkkotunnus.com
  % \end{verbatim}
  %
  % Tässä  /resurssi kuvastaa suhteellista request-URI:a ja GET on verbi.
  %
  % The absoluteURI form is required when the request is being made to a proxy. The proxy is requested to forward the request or service it from a valid cache, and return the response.
  % GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
  %
  % The most common form of Request-URI is that used to identify a
  %    resource on an origin server or gateway. In this case the absolute
  %    path of the URI MUST be transmitted (see section 3.2.1, abs_path) as
  %    the Request-URI, and the network location of the URI (net_loc) MUST
  %    be transmitted in a Host header field.
  %
  %    For example, a client wishing
  %       to retrieve the resource above directly from the origin server would
  %       create a TCP connection to port 80 of the host "www.w3.org" and send
  %       the lines:
  % GET /pub/WWW/TheProject.html HTTP/1.1
  % Host: www.w3.org
  %
  % followed by the remainder of the Request. Note that the absolute path
  %    cannot be empty; if none is present in the original URI, it MUST be
  %    given as "/" (the server root).
  %
  %
  %
  %      http://ftp.ics.uci.edu/pub/ietf/http/rfc2068.txt
  %
  %      For definitive information on URL syntax and semantics, see RFC 1738
  %         [4] and RFC 1808 [11].
  %
  %
  % The use of IP addresses in URL's SHOULD be avoided whenever possible (see RFC 1900 [24])
  %
  % If the abs_path is not present in the URL, it MUST be given as "/" when used as a Request-URI for a resource (section 5.1.2).

  \subsection{Käsitteet URI, URL ja URN} % (fold)
  \label{sub:käsitteet_uri_url_ja_urn}

  % subsection käsitteet_uri_url_ja_urn (end)
  \verb!URI! (Universal Resource Identifier) on tapa yksilöidä sisältöä internetissä. Sisältö voi olla mitä tahansa: yleisinä esimerkkeinä ovat HTML-sivu, kuvatiedosto tai videostream. Käsitteet \verb!URL! (\emph{Universal Resource Locator}) ja \verb!URN! (\emph{Universal Resource Name}) ovat \verb!URI!:n osajoukkoja (kuva~\ref{fig:uri_url_urn}). Käsitteitä URI ja URL käytetään usein hämmentävästi ristiin~\cite{w3c_uri_clarifications} ja URN ei ole monestikaan webissä relevantti. HTTP-kontekstissa URI tarkoittaa ainoastaan muotoiltua merkkijonoa, joka yksilöi resurssin sen nimen, sijainnin tai muun ominaispiirteen perusteella~\cite{ietf_rfc_http1.1}.

  \verb!URL! on sisällön tietyssä sijainnissa yksilöivä tunniste. Sisältö sijaitsee resurssissa, ja URL on abstrakti tapa resurssin sijainnin määrittämisen~\cite{ietf_rfc_urls}. Tämän tutkielman URL voisi olla esimerkiksi \url{http://www.cs.helsinki.fi/u/repo/gradu/g.pdf}, jossa \verb!http! on skeema, \url{www.cs.helsinki.fi} verkkotunnus ja \url{u/repo/gradu/g.pdf} on url-polku. Siitä, mitkä voisivat olla tähän URL:iin liittyvät resurssit, kerrotaan tarkemmin kappaleessa~\ref{sub:arkkitehtuurityyli_rest}. URL:n yleinen koostumus on ~\cite{ietf_rfc_urls}:
  \\ \verb!skeema://käyttäjätunnus:salasana@verkkotunnus:portti/url-polku!

  Tämän tutkielman puitteissa oleelliset skeemat ovat \verb!http! ja \verb!https!, joiden puitteissa URL:n käyttäjätunnus, salasana ja portti voidaan jättää URL:sta pois. Portti on http-skeemassa oletusarvoisesti 80~\cite{ietf_rfc_urls} ja https-skeemassa 443~\cite{ietf_rfc_http_tls}. URL:n loppuosa -- url-polku -- koostuu http(s)-skeeman yhteydessä kauttaviivoin (''/'') erotelluista merkkijonoista, jotka yksilöivät URL:n kuvaaman resurssin verkkotunnuksen asiayhteydessä. Ensimmäinen kauttaviiva verkkotunnuksen (tai portin) jälkeen ei kuulu url-polkuun~\cite{ietf_rfc_urls}. URL-käyttäjätunnuksesta lisää kappaleessa \emph{HTTP Basic Auth}.


  \verb!URN! sisällön yksilöivä nimitunniste. URN on tarkoitettu pysyväksi ja sijainninsta riippumattomaksi resurssin tunnisteeksi, jonka tulee olla ''globaalisti ja pysyvästi uniikki riippumatta sitä kuvaavan resurssin olemassaolosta''~\cite{ietf_rfc_uri_syntax}. URN koostuu nimiavaruudesta sekä nimiavaruudessa yksikäsitteisestä merkkijonosta eli nimitunnisteesta: \verb!urn:nimiavaruus:nimitunniste!~\cite{ietf_rfc_urn_syntax}. Esimerkiksi kirjoja yksilöivä ISBN-tunniste voidaan määritellä URN:n avulla. Tällöin ISBN-numero 0-123-45678-9 olisi URN-muodossa \verb!urn:isbn:0-123-45678-9!~\cite{w3c_uri_clarifications}. Web-kontekstissa kuitenkin käsitteet URL ja URI ovat vakiintuneet käytössä eikä käsitettä URN kohtaa web-kehittäjälle relevanteissa asiayhteyksissä.

  \begin{figure}
    \centering
    \includegraphics[width=0.6\textwidth]{images/uri_url_urn.jpg}
    \caption{Käsitteet URI, URL ja URN}
    \label{fig:uri_url_urn}
  \end{figure}

  % subsection http_protokolla (end)

  \subsection{Rajapinnat ja web} % (fold)
  \label{sub:rajapinnat_ja_web}

  ''Palvelusi kuolee eikä saa käyttäjiä, ellei siinä ole julkista API:a.'' (todo etsi lainaus)

  Sessiopohjainen autentikointi ja restful api. Clientin täytyy pitää yllä tilaa (vs. http basic auth).
  Auktorisointi ja käyttäjän luvan kysyminen: tilan ylläpito välttämätöntä. Kehittäjäresistenssi ''http basic auth helpompi toteuttaa''.

  Erilaisia API-autentikointitapoja on lähes yhtä paljon kuin erilaisia API-toteutuksia. Jokainen oma autentikointitapa vaatii oman autentikointitoteutuksen. Sitä vastoin http basicille, oauthille, samlille ym on jo runsas valmis kirjastotuki.  Älä kehitä omaa autentikointitapaa.

  api-keyt non-sensitive datalle. vrt älä laita session identifier urliin (security). Google maps esimerkki api-keystä: käyttäjien klikkauksia voidaan seurata ja palvelulla voi olla oma käyttömääräkiintiö karttoihin, mutta api-keyllä haettu karttadata ei ole salaista. Eri asia palvelin-palvelin yhteyksissä, joissa api-key ei näy käyttäjälle.

  restapi security vs soap-api ja WS-Security

  % subsection rajapinnat_ja_web (end)

  \subsection{Arkkitehtuurityyli: WS-* ja SOAP} % (fold)
  \label{sub:arkkitehtuurityyli_ws_}
    Web Services (WS-*) on Microsoftin (alkujaan määrittelemä?) kokoelma arkkitehtuurityylejä (todo viite), joiden perusteella voidaan suunnitella web-palvelun arkkitehtuurin eri näkökulmat.

    SOAP ja XML.
  % subsection arkkitehtuurityyli_ws_ (end)


  \subsection{Arkkitehtuurityyli: REST} % (fold)
  \label{sub:arkkitehtuurityyli_rest}

  Määrittele resurssi (http rfc)

  URL määrittää resurssin käyttötavan eli skeeman (\emph{scheme}), ja HTTP-protokollan verbi (GET, POST, UPDATE, DELETE) määrittää operaation tyypin.


  % subsection arkkitehtuurityyli_rest (end)


  \subsection{Arkkitehtuurityyli: SOA} % (fold)
  \label{sub:arkkitehtuurityyli_soa}

  Löyhästi kytketyt palvelut (loosely coupled).
  Mahdollisuus uusien toimintojen lisäämiseen itsenäisinä \emph{palveluina}
  Pitkällä aikavälillä ylläpito ja jatkokehitys helpompaa, koska muutokset vaikuttavat vain palveluun itseensä.
  Palvelut kommunikoivat keskenään rajapintojen kautta, erityisesti yleistynyt on HTTP.
  Rajapinnat määritellään web-kontekstissa joko REST- tai WS-*-arkkitehtuurityylin mukaisesti.

  % subsection arkkitehtuurityyli_soa (end)

% section web_ja_saas (end)


\section{Autentikoituminen ja Web} % (fold)
\label{sec:autentikoituminen_ja_web}

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/usnavy_authentication.jpg}
    \caption{Yhdysvaltain ilmasotajoukkojen toisen maailmansodan ajan koulutusmateriaalia~\cite{usnavy_authentication}}
    \label{fig:yleiskuva}
  \end{figure}


  Pitäisikö otsikon olla ''salasanat ja web'' ja myöhemmin ''autentikoituminen ja web'' ?

  Paradigma: Web, SaaS, HTTP, user-agent/web-browser.
  Mikä on web-palvelu?
  Mikä on sisäinen palvelu?

  Selitä auki tutkimuksen fokus:
  Miksei active directory, kerberos, cas, ldap ole relevantti?
  Voiko niitä kuitenkin hyödyntää (esim. SaaS-palvelu - Google Apps - Active Directory)
  Miksi HTTP suosituin protokolla?

  Mitä tarkoittaa autentikointi?
  Mitä tarkoittaa auktorisointi (authorization)?

  Rajataanko aihe SaaS-palveluihin, jotka julkisesti internetissä?
  - ei oteta kantaa sisäisiin palveluihin?

  Identiteetti: Kuka teki pyynnön?
  Autentikointi: Onko tekijä todella se, joka hän väittää olevansa?
  Auktorisointi: Onko tekijällä valtuudet tehdä se, mitä hän yrittää tehdä?

  Identity Management and Trust Services: Foundations for Cloud Computing
  % http://www.educause.edu/EDUCAUSE+Review/EDUCAUSEReviewMagazineVolume44/IdentityManagementandTrustServ/178410

  %%%%%%%%%%%%%%%%%%
  % ''Assertions are statements from a Verifier to an RP that contain information about a
  % Subscriber. Assertions are used when the RP and the Verifier are not collocated (i.e., they
  % are connected through a shared network). The RP uses the information in the assertion to
  % identify the Claimant and make authorization decisions about his or her access to
  % resources controlled by the RP. An assertion may include identification and
  % authentication statements regarding the Subscriber, and may additionally include attribute
  % statements that further characterize the Subscriber and support the authorization decision
  % at the RP.''
  % %
  % ''There are two basic models for assertion-based authentication. After successful
  % authentication with the Verifier, the Subscriber is issued an assertion or an assertion
  % reference, which the Subscriber uses to authenticate to the RP.''
  % %
  % ''an assertion contains a set of claims or statements about an
  % authenticated Subscriber. Based on the statements contained within it, an authentication
  % assertion will fall into one of two categories (and either category can be used in both
  % direct and indirect models): Holder-of-Key Assertions ja Bearer Assertions. (sivu 83.)''
  % %
  % Lisäksi Proxy-model, jossa käyttäjä <--> verifier/portal <--> relying party.
  % %
  % % ''Three types of assertion technologies will be discussed within this section: Web browser
  % %   cookies, SAML (Security Assertion Markup Language) assertions, and Kerberos tickets''
  % %
  % ''Cookies are effective as assertions for Internet single-sign-on where the RP and Verifier
  % are part of the same Internet domain, and when the cookie contains authentication status
  % for that domain. They are not usable in scenarios where the RP and the Verifier are part
  % of disparate domains.''
  % %
  % Cookies are also often used by the Claimant to re-authenticate to a server. This may be
  % considered to be a use of assertion technology. In this case, the server acts as a Verifier
  % when it sets the cookie in the Subscriber’s browser, and as an RP when it requests the
  % cookie from a Claimant who wishes to re-authenticate to it. Often, the cookie contains a
  % random number, and the assertion data that it represents does not leave the server.
  % % Kpl 9: Assertions
  % % NIST-Special-Publication-800-63-1-E-Authentication-Guidelines.pdf
  % % todo tähän myös Figure 4 ja Figure 5 samasta guidelinesta!


  \subsection{Haaste--Vastine-autentikaatio} % (fold)
  \label{sub:haaste_vastine_autentikaatio}

  \emph{Haaste--vastine-autentikoinniksi} (\emph{challenge-response authentication}) kutsutaan autentikointitapaa, jossa toinen osapuoli esittää kysymyksen (haasteen), johon toisen osapuolen on tarjottava kelvollinen vastaus (vastine) \cite{NIST_SP800-63-1}. Haaste voi olla esimerkiksi satunnaisluku, jonka haastaja lähettää vastaajalle ja johon vastaaja yhdistää jonkin ennalta jaetun salaisuuden. Yhdistäminen voidaan tehdä esimerkiksi laskemalla tiiviste haasteesta ja salaisuudesta, joka lähetetään takaisin haastajalle. Koska haastaja tuntee jaetun salaisuuden, hän pystyy laskemaan oman versionsa tiivisteestä. Haaste voidaan hyväksyä, jos sekä haastajan itse laskema että vastaanottama tiiviste ovat identtiset \cite{NIST_SP800-63-1}.

  Autentikoituminen käyttäjätunnuksella ja salasanalla on yksi haaste--vastine-autentikoinnin sovellus. Salasana-autentikoinnissa toinen osapuoli kysyy käyttäjätunnusta ja salasanaa, johon toisen osapuolen on vastattava täsmälleen oikeanlaisella merkkijonoyhdsitelmällä.

  1990-luvun tietokonepeleissä oli usein kopionestosuojauksia, jotka häiritsivät tai estivät pelaamisen ellei käyttäjä tarjonnut oikeaa vastausta pelin esittämään haasteeseen. Yleensä haasteena oli jokin kysymys, johon löytyi vastaus pelin laillisen kopion mukana toimitetussa paperisessa ohjekirjassa. Motiivina oli tehdä laittoman pelikopion levittäminen pelkkien tiedostojen kopioimista vaivalloisemmaksi, koska tuohon aikaan laajan dokumentin kopioiminen oli työlästä, eivätkä kopiokoneet ja skannerit eivät olleet yleisiä. Tämän tutkielman kirjoittaja vietti ala-asteikäisenä monta iltaa kopioidessaan kynällä ja paperilla tällaisia koodikirjoja itselleen.

  Haasteeseen voi olla myös julkisesti tunnettu vastine. Spämmibottien torjumiseksi kehitetty CAPTCHA-testi (\emph{Completely Automated Public Turing test to tell Computers and Humans Apart}) kysyy kysymyksen (esittää haasteen), johon ihmisen on helppo vastata (tarjota vastine), mutta johon tietokone ei pysty luotettavasti tuottamaan oikeaa vastausta. CAPTCHA-haaste voi olla esimerkiksi yksinkertainen matemaattinen laskutoimitus, bittikarttakuvaan upotettu ihmissilmällä erottuva sana tai yksiselitteinen suomenkielinen kysymys, johon on yksiselitteinen ja yleisesti tunnettu vastaus.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/Facebook_captcha_filled.jpg}
    \caption{Esimerkki CAPTCHA:n käytöstä Facebookissa}
    \label{fig:yleiskuva}
  \end{figure}

  % subsection haaste_vastine_autentikaatio (end)

  \subsection{Autentikoituminen web-palveluissa} % (fold)
  \label{sub:autentikoituminen_salasanalla}

  Web-palvelun asiakas (todo termi) autentikoituu todistamalla, että hänellä on hallussaan ja hallinnassaan \emph{poletti} (\emph{token}). Poletti on rekisteröity ennakkoon web-palvelun käyttämälle identiteetintarjoajalle, ja sitä vastaan web-palvelu (identiteetin kuluttaja) voi varmistua poletin \emph{kantajan} (\emph{bearer}). Poletin kantajana toimivaa asiakasta kutsutaan \emph{väittäjäksi} (\emph{claimant}), koska asiakkaan identiteetti perustuu yksipuoliseen väittämään, kunnes autentikointitapahtuma on suoritettu ja väittäjä todistanut identiteettinsä. Polettiin liittyy salaisuus (\emph{secret}), jolla väittäjä osoittaa, että hän on poletin rekisteröimisen yhteydessä palveluun määritetty toimija (\emph{subscriber})~\cite{NIST_SP800-63-1}. Salaisuus perustuu joko julkiseen avainpariin (asymmetrisiin avaimiin, \emph{asymmetric keys}) tai \emph{jaettuun salaisuuteen} (\emph{shared secret}).

  \emph{Julkinen avain} ja sitä vastaava \emph{yksityinen avain} muodostavat \emph{julkisen avainparin} (\emph{public key pair})~\cite{NIST_SP800-63-1}.
  Polettiin on varastoitu joko yksityinen avain kokonaisuudessaan~\cite{NIST_SP800-63-1} tai viite siihen (todo etsi esimerkki).
  Identiteetintarjoaja tallettaa poletin rekisteröimisen yhteydessä avainparin julkisen avaimen itselleen. Tyypillinen menetelmä on varastoida julkinen avain \emph{sertifikaattiin} ja tallettaa se identiteetintarjoajalle. Tällöin identiteetintarjoaja voi soveltaa julkiseen avainpariin perustuvaa autentikointiprotokollaa ja esittää väittäjälle haasteen, jonka vastaus edellyttää avainparin yksityisen komponentin tuntemista -- eli pääsyä polettiin.

  \emph{Jaettu salaisuus} voi olla joko \emph{symmetrinen avain} (\emph{symmetric key}) tai salasana~\cite{NIST_SP800-63-1}. Näitä kahta voidaan käyttää samankaltaisissa autentikointiprotokollissa, mutta merkittävnä erona on niiden näkyminen käyttäjälle. Symmetrinen avain on tyypillisesti kytketty johnonkin käyttäjän hallinnoimaan laitteeseen tai ohjelmistoon, mutta salasana täytyy muistaa ulkoa. Muistettavuuden vuoksi salasanat ovat kryptografista avainta pituudeltaan lyhyempiä merkkijonoja, joten salasanalla on vähemmän erilaisia mahdollisia arvoja kuin avaimella. Symmetristä avainta ja salasanaa käytetätään sen vuoksi eri käyttötarkoituksiin.

  todo kuva; miksi puhutaan poletista. Hashed passwords --> palveluntarjoaja ei talleta salasanaa vaan hashin, eli palveluntarjoajallakin on poletti.


  % subsection autentikoituminen_salasanalla (end)

  \subsection{Salasanat ovat vallitseva käytäntö} % (fold)
  \label{sub:salasanat}
  Salasanojen vahvuus, ihmisten tapa käyttää salasanoja, salasanat kustannustehokas ratkaisu.
  Ihmiset eivät muista salasanoja. Sama salasana monessa paikassa. Ongelma.

  Yhdistä tähän kappaleet Salasanat ja Salasanat ovat vallitseva käytäntö

  Salasana on jaetun salaisuuden toteutus, ja salasanat ovat yleisin tapa tunnistautua palveluihin internetissä \cite{study_of_passwords_07, passpet_06, password_management_strategies_06, pwdhash_extension_05}.
  Salasanan turvallisuus riippuu salasanan uniikkiuden (ei käytössä muissa palveluissa) lisäksi siitä, kuinka työläs se on arvata joko väkisin tai hyödyntäen sosiaalista tiedonkeruuta. Koska pitkät ja vaikeat salasanat ovat myös vaikeampia muistaa kuin lyhyet ja helpot, loppukäyttäjät päätyvät usein käyttämään samaa salasanaa monessa eri palvelussa \cite{study_of_passwords_07}. Turvattomin vaihtoehto on, että käyttäjällä on lyhyt ja helppo salasana kaikissa käyttämissänsä palveluissa.

  Saman salasanan käyttäminen monessa palvelussa on riski. Jos käyttäjän salasana päätyy vääriin käsiin yhden palvelun kautta, vaarantuvat samalla kaikki muut palvelut, joissa käyttäjällä on sama salasana. Esimerkiksi joulukuussa 2010 Gawker.com-juorupalvelun tietomurron yhteydessä 1,3 miljoonaa salasanaa päätyi kerralla vääriin käsiin, kun kaikki kerätyt salasanat vuodettiin julkisiksi \cite{bbc_gawker_12_2010, forbes_gawker_12_2010}. Juorujen kommentoimiseksi luotujen käyttäjätunnusten vuotaminen oli ongelmallista, koska moni käyttäjä käytti samaa salasanaa myös muissa palvelussa. Tämän seurauksena esimerkiksi Twitterissä havaittiin käyttäjätunnuksia valloittanut spämmiaalto. Lisäksi mielenkiintoista oli, että vuodetuista salasanoista 1.958 kappaletta oli ''password'' \cite{forbes_gawker_12_2010}.

  % GAWKER salasanat, kuva http://blogs.wsj.com/digits/2010/12/13/the-top-50-gawker-media-passwords/?mod=e2tw

  % Rational rejection of security advice by users
  % http://research.microsoft.com/en-us/um/people/cormac/papers/2009/SoLongAndNoThanks.pdf

  Turvallinen salasana edellyttää hankalaa arvattavuutta ja uniikkiutta. Florêncio ja Herley \cite{study_of_passwords_07} tutkivat ihmisten salasanatapoja kolmen kuukauden ajan 500.000 käyttäjän aineistolla. He havaitsivat, että keskimääräisellä käyttäjällä on 6,5 salasanaa, joista jokainen on jaettu 3,9 eri palvelun kesken. Jokaisella käyttäjällä on keskimäärin 25 salasanaa vaativaa käyttäjätunnusta ja päivittäin kirjoitetaan keskimäärin 8 salasanaa. Käyttäjän ongelmana on siksi usein muistaa, mikä kuudesta eri salasanasta sopii juuri tiettyyn palveluun. Moni käyttäjä kokeilee palveluun vuorotellen kaikkia salasanojansa, kunnes oikea löytyy \cite{study_of_passwords_07}. Tämä on väärinkäytösten osalta ongelmallista, jos palvelu tallettaa kokeillut salasanat luettavassa muodossa jonnekin.

  % subsection salasanat (end)

  \subsection{Kaksi- ja monivaiheinen autentikointi} % (fold)
  \label{sub:kaksivaiheinen_autentikointi}

  Perus-haaste-vastine-autentikoinnissa jos tietoliikenneyhteys (tai muu kommunikaatiokanava) ei ole turvallinen tai vastine muilla tavoin päätyy vääriin käsiin, salakuuntelija (eavesdropper) voi oppia jokaisen esitetyn haasteen vastineen, ja (väärin)käyttää vastinetta itse.
  Tällaisia mitm, troijalaiset, social engineering, olanylikatselu jne.

  Kaksivaiheisuus tuo autentikointiin lisävaiheen. Haaste--vastine-autentikoinnissa käyttäjän on annettava esitettyyn haasteeseen kelvollinen vastine eli osoitettava toiselle osapuolelle että hän \emph{tietää} jotain. Kaksivaiheisessa autentikoinnissa käyttäjän on lisäksi osoitettava, että hänellä \emph{on hallussaan} jotain \cite{NIST_SP800-63-1, google_2step_2010}. Jälkimmäinen tekijä voidaan muodostaa esimerkiksi lähttämällä käyttäjän puhelinnumeroon vahvistuskoodin sisältävä tekstiviesti tai kysymällä merkkijonoa, jonka jokin ulkoinen laite tuottaa. Autentikoinnin suorittamiseksi käyttäjän on tietyn ajan sisällä esitettävä kelvollinen vastine molempiin haasteisiin.

  Internet-palveluissa yleisin kaksivaiheisuuden toteutustapa on käyttäjän matkapuhelimen hyödyntäminen. Tekstiviestillä käyttäjä pystyy osoittamaan pitävänsä hallussa ennalta tunnettua puhelinnumeroa (hyvänä puolena toimivuus kaikissa tekstareita tukevissa puhelimissa). Toinen yleinen keino on \emph{Google Authenticator} -älypuhelinsovelluksen hyödyntäminen. Google Authenticator -mobiilisovellus tarjoaa rajoitetun ajan voimassa olevan numerosarjan, jota autentikoiva palvelin kysyy onnistuneen salasana-autentikoinnin jälkeen. Älypuhelinsovelluksen hyvänä puolena on riippumattomuus puhelinverkkoyhteydestä, mutta toimiakseen sovellus vaatii tietynlaisen puhelinmallin. Google Authenticator -projektin taustajärjestelmä (\emph{backend}) sekä iOS, Android ja Blackberry -mobiilisovellukset on julkistettu avoimena lähdekoodina (todo lähdeviite http://code.google.com/p/google-authenticator/), minkä ansiosta sillä on mahdollista toteuttaa autentikoinnin kaksivaiheisuus myös Googlesta täysin riippumattomiin palveluihin.

  Internet-mittakaavassa ulkoisen laitteen edellyttäminen hankaloittaa autentikointitavan laajaa käyttöönottoa. Ulkoisista laitteista matkapuhelin on suosittu juuri yleistyneisyytensä vuoksi. On kuitenkin olemassa myös muita ulkoisia laitteita, jotka tarjoavat mahdollisuuden kaksivaiheistaa autentikointi -- näitä käytetään usein yritysverkoissa tai muissa keskitetysti hallituissa verkkoympäristöissä. Osa laitteista markkinoi itseänsä myös salasanan korvaajina ja jotkut palvelut kuten verkkopankit jakavat etukäteen käyttäjilleen listan kertakäyttöisistä salasanoista. Tällöin kyseessä on kuitenkin yksivaiheinen haaste--vastine-autentikointi ellei laitteen tai kertakäyttösalasanalistan lisäksi vaadita mitään muuta tunnistetta.

  Kaksivaiheinen autentikointi on monivaiheisen autentikoinnin (\emph{multifactor authentication}) toteutus (todo termi, erikoistus?).
  Vaiheiden \emph{jotain minkä tiedot} ja \emph{jotain minkä omistat} lisäksi voidaan vaatia \emph{jotain mitä olet} -- tällöin kyse on kolmivaiheisesta autentikoinnista. Vaiheeksi \emph{jotain mitä olet} sopii esimerkiksi sormenjälki, iiriksen skannaaminen tai muu biometrinen tunniste. Monivaiheinen autentikointi tarkoittaa vähintään kahden edellä mainitun vaiheen käyttöä asiakkaan (todo termi, \emph{claimant}) tunnistamiseksi \cite{NIST_SP800-63-1}. Monivaiheisen autentikoinnin toteutus on yleisesti käsitetty vahvemmaksi kuin vain yhtä vaihtetta käyttävä: kolmen vaiheen autentikointi on vahvempi kuin kuin kahta vaihteta käyttävä, ja kahden autentikointivaiheen kokonaisuus on vahvempi kuin yhden vaiheen vaiheen toteutus \cite{NIST_SP800-63-1}. Myös karttapaikannustietoa tai laitteen yksilöivää tunnistekoodia voidaan käyttää autentikointiprosessin tukena, mutta ne eivät kuitenkaan ole autentikointitapoja (\emph{authentication factors}) \cite{NIST_SP800-63-1}.

  Kokonaisturvallisuutta lisäävästä vaikutuksestaan huolimatta monivaiheinen autentikointi ei itsessään ratkaise \emph{man-in-the-middle}-ongelmaa \cite{schneier_2factor_2005}. Jos kolmas osapuoli pääsee tietoliikenneyhteyden väliin, hän voi välittää kaikki käyttäjän viestit eteenpäin. Man-in-the-Middle ei näe haastetta, jonka palveluntarjaoja lähettää kaksivaiheisessa autentikoinnissa käyttäjän matkapuhelimeen. Hän kuitenkin näkee kaapatun tietoliikenneyhteyden kautta käyttäjän haasteeseen tarjoaman vastineen ja pystyy välittämään sen eteenpäin palveluntarjoajalle. Vaikka tiedonsiirtokanava olisi turvallinen, käyttäjän huolimattomuuden, päätelaitteessa olevan troijalaisen tai vakoiluohjelmiston on edelleen mahdollista aiheuttaa MITM-turvallisuusongelma (todo viite security ignorance). Monivaiheisuus lisää kuitenkin hyökkäyksen vaatimaa työläyttä yksivaiheiseen autentikointiin verrattuna.


  % Esimerkkejä laitteista ovat YubiKey (http://www.yubico.com/yubikey, hyvänä puolena edullinen \$25 hinta), RSA SecurID (http://www.rsa.com/node.aspx?id=1156, huono julkisuus SecurID tietomurto 03/2011)
  % Tectia Mobile ID: Kun käyttäjä kirjautuu palveluun, kännykkään lähetetään (flash-)tekstiviestinä viisinumeroinen koodi, joka pitää syöttää palveluun normaalin salasanan lisäksi.
  % Amazon AWS Multi Factor http://aws.amazon.com/mfa/
  % RSA Murto tapahtui Phishingillä: http://blogs.rsa.com/rivner/anatomy-of-an-attack/

  % TODO: lähdeviite
  % http://support.google.com/accounts/bin/answer.py?hl=en&answer=1066447
  % http://www.mnxsolutions.com/security/two-factor-ssh-with-google-authenticator.html

  % subsection kaksivaiheinen_autentikointi (end)


  \subsection{Sertifikaatit webissä} % (fold)
  \label{sub:sertifikaatit_webissä}
  Julkisen avaimen infrastruktuutri.
  Diffie-Hellman.
  Sertifikaatit, luotettava kolmas osapuoli.
  HTTP-yhteyden suojaus SSL/TLS-tekniikalla, HTTPS.
  Client-sertifikaatit. Ei vielä yleistynyt. Silti sama cert monessa eri palvelussa. Revoke hankalaa. OpenID+cert olis hyvä.
  WebID-draft.

  % subsection sertifikaatit_webissä (end)

  \subsection{HTTP Basic Auth ja HTTP Digest Auth} % (fold)
  \label{sub:http_basic_auth_ja_http_digest_auth}
  Tässä kerrotaan mikä on basic auth (\verb!http://tunnus:salasana@osoite.fi/uri!) ja mikä on http digest auth (haaste-vastine http headereissa).

  % It is clearly unwise to use a URL that contains a password which is
  % intended to be secret. In particular, the use of a password within
  % the 'userinfo' component of a URL is strongly disrecommended except
  % in those rare cases where the 'password' parameter is intended to be
  % public.
  % rfc 2396


  % subsection http_basic_auth_ja_http_digest_auth (end)


  \subsection{Sessiopohjainen autentikointi} % (fold)
  \label{sub:sessiopohjainen_autentikointi}
  Tässä kerrotaan, miten keksejä käytetään autentikoinnissa.

  Cookiet, user-agent, API.

  Client-server, server-server. Application-Useragent-Server.

  whitepaper: ''Is your API naked ?''
  %http://blog.apigee.com/detail/more_api_security_choices_oauth_ssl_saml_and_rolling_your_own/

  session fixation attack % http://www.readwriteweb.com/archives/how_the_oauth_security_battle_was_won_open_web_sty.php


  % subsection sessiopohjainen_autentikointi (end)

  \subsection{Kommunikaatiotavat: front-channel ja back-channel} % (fold)
  \label{sub:kommunikaatiotavat_front_channel_ja_back_channel}

  Front Channel yksinkertainen toteutus kun HTTP-binding. Tällöin ainoastaan user-agent on viestinvälittäjä, mikä mahdollistaa yksinkertaisen protocol flown.

  Korkeampaa turvallisuustasoa tai tiukempaa yksityisyyttä tavoiteltaessa kokonaisen viestin sijasta user-agent voi välittää pelkän \emph{viitteen} tietoon. Tällöin user-agentin viitteeseen liitetty varsinainen tieto (esim. SAML-assertio, artifakti) välitetään palvelin-palvelin-yhteydellä back-channelin kautta kyseisen user-agentin antaman viitteen perustella.

  SAML ja back-channel määritellään SOAP-viestinvälityksenä (SAML over SOAP over HTTP).
  (viite %http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language)

  % subsection kommunikaatiotavat_front_channel_ja_back_channel (end)
% section autentikoituminen_ja_web (end)


  \subsection{Selain-, sisältö- ja applikaatiokonteksti} % (fold)
  \label{sub:selainkonteksti_vs_applikaatiokonteksti}

  Selainkontekstissa käyttäjä voi luottaa siihen, mitä osoiterivillä lukee, kun työasema oletetaan turvalliseksi (ei troijalaisia tms). Selaimen oman ulkonäön ja turvallisuustoimien väärentäminen erittäin työlästä. Kuvassa~\ref{fig:facebook_reauth_ab} selaimen URL-osoiterivillä oleva, turvallista HTTPS-yhteyttä kuvaava lukko (A) ilmaisee, että yhteys selaimen ja palvelimen välillä on suojattu. Selainkontekstissa käyttäjän on mahdollista varmistua siitä, että oikea sivusto kysyy salasanaa. Selaimen osoiterivillä täytyy olla palvelua vastaava URL-osoite (B). Pelkkä lukko ei vielä takaa turvallisuutta, koska se ilmaisee ainoastaan selaimen ja palvelun välisen yhteyden olevan turvallinen. Käyttäjän itsensä täytyy voida varmistua siitä, että yhteys on \emph{oikeaan palveluun}. Käyttäjää on mahdollista jekuttaa selainkontekstissa lukon kuvalla, jos osoiterivillä esim. ''faceboook.com''.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/Facebook_reauth_ab.jpg}
    \caption{Turvallisuusilmoitukset selainkontekstissa}
    \label{fig:facebook_reauth_ab}
  \end{figure}

  Käyttäjä ei voi luottaa selaimen sisältökontekstin turvallisuusilmoituksiin. Käyttäjä saattaa tulla huijatuksi, jos hän ei kiinnitä huomiota selaimen turvallisuusilmoituksiin tai niiden puutteeseen~\cite{why_phishing_works_06}. Modernit selaimet näyttävät useita erilaisia ilmaisimia turvalliselle HTTPS-yhteydelle, mutta suojaamattomalle yhteydelle ei ole vakiintunutta ilmaisinta. Monet käyttäjät eivät kiinnitä lainkaan huomiota ilmaisimiin, ja monesti käyttäjä on tyytyväinen sivun sisältökontekstissa olevaan turvallisuusilmoitukseen. Kuvassa~\ref{fig:trust_context_html} HTML-sisältösivu itse ilmoittaa olevansa turvallinen (D) ja näyttää sisältöosassa lukon kuvan. Ilmoitus on hyväntahtoinen, mutta tässä tapauksessa käyttäjä voi luottaa ainoastaan siihen, että selaimen osoiterivillä oleva palvelu (C) on luotettava. Sisältökontekstissa voi kuitenkin olla käyttäjän kannalta hyödyllistä ilmoittaa, jos sisäänkirjautumisyhteys \emph{ei ole} turvallinen (kuva~\ref{fig:trust_context_html_unsecure}): tällöin käyttäjä voi halutessaan olla syöttämättä salasanaansa esimerkiksi kahvilan avoimessa WLAN-verkossa.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/trust_context_html.jpg}
    \caption{Turvallisuusilmoituksia selain- (C) ja sisältökontekstissa (D)}
    \label{fig:trust_context_html}
  \end{figure}


  \begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/trust_context_html_unsecure.png}
    \caption{Turvattomuusilmoitus sisältökontekstissa}
    \label{fig:trust_context_html_unsecure}
  \end{figure}


  Applikaatiokonteksti on relevantti erityisesti mobiilikäyttöjärjestelmissä, joissa yleistyneet sosiaalisen median toiminnot luovat tarpeen luotettavalle tavalle autentikoitua. Mobiilikäyttöjärjestelmistä esimerkiksi Android ei rajoita sovellusten asentamista, eikä myöskään Android Marketista asennettujen ohjelmistojen turvallisuudesta ole takeita (todo etsi viite tietomurtojuttuun). Siksi käyttäjän salasanan kirjoittaminen on syytä tehdä varmasti luotettavassa applikaatiossa kuten mobiilijärjestelmän omassa web-selaimessa tai kohteena olevan palvelun virallisessa applikaatiossa.

  Esimerkiksi Facebookin SDK pyrkii ensisijaisesti avaamaan virallisen Facebook-applikaation, kun kolmannen osapuolen applikaatio pyytää käyttäjää autentikoitumaan Facebook-tunnuksillaan tai pyytää käyttöoikeutta hänen Facebook-tietoihinsa (kuva~\ref{fig:trust_context_mobile_fb}). Jos virallista Facebook-applikaatiota ei ole asennettu, SDK:n toissijainen menetelmä on avata autentikointitapahtuma järjestelmätason web-selaimessa (kuva~\ref{fig:trust_context_mobile_unknown_secure}), jolloin käyttäjä voi varmistua palvelun autenttisuudesta selaimen osoiterivin perusteella. Vasta viimeisenä vaihtoehtona, jos mobiililaite ei tue useamman sovelluksen rinnakkaista suorittamista (\emph{multi-tasking}), Facebook SDK suorittaa autentikoinnin applikaatiokontekstissa (viite \verb=https://developers.facebook.com/docs/mobile/ios/build/#implementsso=).

  \begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/trust_context_mobile_fb.png}
    \caption{Käyttöoikeuspyyntö mobiilikontekstissa. Käyttäjä on autentikoitunut Facebook-applikaation kontekstissa jo aiemmin, joten sisäänkirjautuminen on käytettävissä kolmannen osapuolen sovellukselle ilman salasanan syöttämistä.}
    \label{fig:trust_context_mobile_fb}
  \end{figure}

  \begin{figure}
    \centering
    \includegraphics[width=0.5\textwidth]{images/trust_context_mobile_unknown_secure.png}
    \caption{Autentikointi mobiilissa selainkontekstissa. Selaimen yläpalkissa ei ole turvallista yhteyttä esittävää lukon kuvaa, joten käyttäjä ei voi varmistua näytetyn sivuston autenttisuudesta.}
    \label{fig:trust_context_mobile_unknown_secure}
  \end{figure}

  % "Salasanaa ei saa kysyä mobiiliapplikaation sisällä:" http://fireeagle.yahoo.net/developer/documentation/oauth_best_practice

  Jos käyttäjä valmiiksi sisäänkirjautunut OAuth-palveluun (esim. Facebook), sisältöcontextissa voidaan näyttää authorization overlay (todo selitä termi, vrt popup ja piirrä kuva), jossa käyttäjä joko sallii tai kieltää tietojensa jakamisen. Overlay-sivu tarjoillaan suoraan Facebookista, jolloin facebookin cookie on valmiiksi käytettävissä jolloin facebookin ei tarvitse kysyä salasanaa. Pahantahtoinen applikaatio ei saavuta mitään tämän sivun spooffaamamisella.

  Tilanne on eri, jos OAuth-sisäänkirjautumista ei ole vielä tapahtunut, jolloin käyttäjän täytyy syöttää salasanansa. Tällöin salasanaa ei voida kysyä app trust -kontekstissa, koska mikä tahansa palvelu pystyy tekemään facebook-loginsivun näköisen sivun. Myöskään mikään selaimen anti-phishing toiminto ei laukea, koska kaikki tapahtuu luvallisesti applikaation omassa trust kontekstissa. Delegoidun autentikoinnin perusperiaatteena on päästä eroon salasanan syöttämisestä kolmannen osapuolen sivustolle, mutta OAuth-salasanan kysyminen app trust kontekstissa antaa käyttäjälle mielikuvan, että salasana syötetään kolmannen osapuolen palveluun. Ideologian mukainen tapa on avata sisäänkirjautuminen selainkontekstissa, jolloin selaimen phishing-turvallisuusominaisuudet estävät käyttäjän syöttämien tietojen kaappaamisen kolmannen osapuolen palveluun ja (tärkeintä) käyttäjä näkee siirtymän toiseen palveluun (osoiterivillä facebook.com). (todo: selitä ylempänä mikä on DOM ja että miksi OAuth autentikointi pitää tehdä eri DOMissa kuin missä 3-osapuolen palvelu on.)

  % subsection selainkonteksti_vs_applikaatiokonteksti (end)

  \subsection{Uhat turvalliselle autentikoitumiselle ohjelmistokehittäjän näkökulmasta} % (fold)
  \label{sec:uhat_turvalliselle_autentikoitumiselle}
    HTTPS aina kaikelle sensitiiviselle. API-avaimen, OAuth-tokenin tai muun pystyy kaappaamaan verkkoliikenteestä ilman HTTPS:ää.

    Suojauksen implementointi on transport layerin tehtävä. Transport layerin on oltava turvallinen!

    Osoitetaanko miksi HTTPS on aina tarpeellinen?

    OAuth security token -tyypit:
    - Bearer vaatiin aina HTTPS:n.
    - Mac (vrt. token scheme oauth 1.0), turvallinen vaikkei suojattu yhteys. Vaatii keyn ja secretin, ja käyttää hashmacia kryptaamaan osan requestista. Seurauksena pyyntö valid ainoastaan jos molemmilla osapuolilla samat avaimet, kolmannen osapuolen ei ole mahdollista uudelleenluoda alkuperäistä requestia ilman validia salasanaa.
    - SAML Mahdollistaa SAML-assertioiden käytön. Mahdollistaa olemassaolevan SAML-toteutuksen hyödytämisen OAuthissa. (todo esimerkki milloin hyödyllinen, esim. sisäverkon active directory + julkinen web-palvelu)

    Mitkä on Pihvin kannalta oleellisimmat?
    OAuth draftin threat model -dokumentti.

    Haavoittuvuudet, jotka huomioitava, vaikka yhteys olisi suojattu HTTPS:llä:
    CSRF: OAuth draft kpl 10.12.: ''The client MUST implement CSRF protection for its redirection URI.''
    Clickjacking: Oauth draft kpl 10.13.
       ''To prevent this form of attack, native applications SHOULD use
       external browsers instead of embedding browsers in an iframe when
       requesting end-user authorization.''
    Code Injection ja Input Validation (kpl 10.14.)
    Open Redirectors (kpl 10.15.)

    Phishing ja selaimen omat vastatoimet.

  % section uhat_turvalliselle_autentikoitumiselle (end)



\section{Identiteetti internetissä} % (fold)
\label{sec:identiteetti_internetissä}
  Tämä pääluku todennäköisesti putoaa kokonaan pois ja sen relevantit asiat käsitellään alalukuina kertakirjautumisluvussa.

  7 Laws of Identity.
  Microsoftin visio identiteetistä. Miksi .NET Passport epäonnistui?
  Miksei OpenID yleistynyt?
  Miksi Facebook koetaan uhkana? (vrt 2500 sivua dataa keskivertokansalaisesta vs kgb/cia vs eu-lait)
  Miksei Facebook-tunnusta voi käyttää kaikkialla?
  Eri järjestelmien pitää toimia keskenään yhteen, jotta yksi identiteetti riittäisi.
  Fyysisen laitteen vaativat tekniikat, niiden ongelmat. (HST-kortti, SIM-kortti)
  Jos palvelu ei luota Facebook Connectiin mutta autentikoi käyttäjän FBC:llä, palvelu voi lisäksi kysyä omaa salasanaa (tai käyttää 2-factor).

  \subsection{Käyttäjäkeskeinen identiteetti} % (fold)
  \label{sub:käyttäjäkeskeinen_identiteetti}

  % subsection käyttäjäkeskeinen_identiteetti (end)

  \subsection{Saittikeskeinen/federated identiteetti} % (fold)
  \label{sub:saittikeskeinen_identiteetti}
  Onko saittikohtainen identity eri asia kuin federated identity?
  Tarviiko federated identityssä idp:n luottaa id consumeriin?
  - idp:n täytyy tuntea id consumer

  Tarvitseeko Facebook Connectissa idp:n tuntea idc?
    % - In order to log the user into your site, three things need to happen. First, Facebook needs to authenticate the user. This ensures that the user is who they say they are. Second, Facebook needs to authenticate your website. This ensures that the user is giving their information to your site and not someone else. Lastly, the user must explicitly authorize your website to access their information. This ensures that the user knows exactly what data they are disclosing to your site.
    % - auktorisointipäätös käyttäjälle itselleen (ei automaatille)


  % subsection saittikeskeinen_identiteetti (end)

  \subsection{Directed Identity} % (fold)
  \label{sub:directed_identity}

  % subsection directed_identity (end)

  \subsection{Korttiperusteinen identiteetti (card-based identity)} % (fold)
  \label{sub:korttiperusteinen_identiteetti_card_based_identity_}

  % subsection korttiperusteinen_identiteetti_card_based_identity_ (end)
  \subsection{Luottamusmalli (Trust Model)} % (fold)
  \label{sub:luottamusmalli_trust_model_}
  Milloin tarvitaan trust model? Kun halutaan vaihtaa dataa palvelujen kesken? Onko Facebook Connectissa Trust Model?

  Jos palvelu ei luota Facebook Connectiin mutta autentikoi käyttäjän FBC:llä, palvelu voi lisäksi kysyä omaa salasanaa (tai käyttää 2-factor).

  Luottamussuhteet ja vaatimukset, OpenID vs. OAuth vs. SAML.

  % subsection luottamusmalli_trust_model_ (end)
% section identiteetti_internetissä (end)


\section{Kertakirjautuminen internetissä (Single-Sign On, SSO)} % (fold)
\label{sec:Kertakirjautumisstandardit}
  \begin{quote}
      ''The fool saith, 'Put not all thy eggs in one basket' ...
      but the wise man saith, 'Put all your eggs in one basket, and watch that basket!' ''
      \\--- Mark Twain \cite{twain_eggs_1894}
  \end{quote}

  Historia, miksi keskitetty kertakirjautumissysteemi on ollut tarpeellinen.
  Milloin ja minkä toimijoiden aloitteesta SAML, OAuth, OpenID ovat syntyneet. Alunperin minkä ongelman ratkaisemiseksi?

  % Onko CAS relevantti?
  % Onko LDAP relevantti?
  % Onko SASL relevantti?
  % Onko Shibboleth relevantti? % https://wiki.shibboleth.net/confluence/display/SHIB2/UnderstandingShibboleth
  % Miten Shibboleth ja SAML eroavat toisistaan? % http://shibboleth.internet2.edu/Shibboleth-SAML-FAQ.html
  % Onko Information Cards relevantti?
  % Onko User Provisioning käsitteenä relevantti?
  % Vaikuttaako REST / SOAP siihen, mitä kannattaa käyttää?
  % Onko WS-Trust ja WS-Federation relevantteja?

  Mikä on ''Circle of Trust?'' Onko se federated identityn juttu? Tarvitaanko sitä? Onko sama kuin PGP/GPG:ssä?

  Missä tilanteessa Microsoft Active Directory relevantti?
  - AD voi toimia SAML IdP:nä
  - Windows Live voi toimia OpenID IdP:nä
  - ''AD FS can interact with other WS-* and SAML 2.0 compliant federation services as federation partners.''
    % http://en.wikipedia.org/wiki/Active_Directory_Federation_Services

  Cloud: Datan jakaminen rajapinnan kautta palvelujen kesken.

  Autentikointipalvelujen keskittyminen. Soundcloud ei suosittele enää 3rd party devaajille password auth flowta, koska ''With the introduction of Login with Facebook we discourage the use of this flow since a lot of users simply don't have a password set anymore and thus can't use this flow.''


  Onko kaikissa relevanteissa protokollissa aina HTTP-rajapinta?
  - OpenID aina http, SAMLissa muitakin. Entä OAuth?

  HTTP rules erityisesti silloin kun user-agenttina on selain. Miksi rules myös natiiviapplikaatioissa ja SOA:ssa?
  Kun OAuth vie IdP:lle HTTP:llä, selain näyttää osoiterivillä idp:n domainin ja selainkontekstin turvallisuusilmoitukset (lukon kuva jne).
  Jos kertakirjaútuminen tapahtuisi HTTP:n sijaan esim. Kerberoksella tai muulla, web-selain ei osaisi kommunikoida ellei pluginia tai toteutusta.
  Tällöin kolmannen osapuolen palvelu joutuisi kysymään käyttäjän idp:n salasanaa suoraan ja hoitamaan autentikoinnin back-channelissa käyttäjältä näkymättömissä.
  Kun HTTP on yhteinen protokolla, selainta voi käyttää kaikkeen.
  Lisäksi Javascriptin yleistyminen: nykyisellään trendinä on selaimessa suoritettavan koodin runsastuminen (etsi Fat Clients -lähde).


  % Historia:
  % https://docs.google.com/document/pub?id=1O7jyQLb7dW6EnJrFsWZDyh0Yq0aFJU5UJ4i5QzYlTjU#h.fvyllnfjm3eo
  % http://goo.gl/R8pMP
  % The hack that makes Internet Identity possible
  %
  % Most of the people who will read this guide are computer scientists, and generally computer scientists like to think that account systems should be simple tools.  Unfortunately these systems are used by non-technical users who will not constrain themselves to our rules whether because they don’t understand them, or are hackers trying to break them.  Add in legal, privacy, and security issues, and you unavoidably end up with a complex set of requirements that are very hard to fulfill, and in many cases the requirements are conflicting.  Hopefully this guide will help you balance and meet those requirements.
  % The most common computer science requirement of a User Account system is to provide a unique numeric ID for an account.  In a “simple” computer science world, there would be one global user account system, similar to DNS, where every person was assigned a single unique numerical ID at birth, and each person also had a perfect way to prove who they were.  Every website could then use those user IDs to store information associated with the person.
  % Obviously that does not exist, and for decades every user account system issued its own IDs (and sometimes usernames) to users.  Such systems were “simple” to write, but painful for users.
  % Then during the early 90s, a “hack” was found that created the foundation of most user account systems on the web.  That “hack” was the idea of logging into a website with your email address, and proving you were the owner of that email address by having the site send you an SMTP message with a hyperlink back to the site which contained a long code.  For the few of us who considered ourselves identity geeks at the time, this did not seem like an approach that would last a long time.  Even SMTP seemed like a fad when we already had high end systems like Lotus Notes relying on things like PKI, digital certifications, signing, encryption, etc.
  % However twenty years later, that “hack” is still the most powerful technique that we rely on to build user account systems.  From a purist perspective, emails have some downsides as identifiers. Much of this guide will discuss those downsides, and how to handle them.  However nothing else, even phone numbers or social network IDs, has come even close to being as powerful an identifier.
  % Two of the downsides are that users change email address over time, and that the same email address is sometimes assigned to different people at different time periods.  Because of those, and other complications, almost every website still maintains its own “local ID” system just as user accounts did before the 90s.  The one key addition is that those local IDs are then mapped to and from a user’s email address.
  %
  % Human -> Emails -> Local IDs -> Passwords
  %
  % So humans have a map of the emails they use, and websites map an email to a local ID.  Website’s user account systems also have a critical role of authenticating the owner of that email address.  Note we did not say authenticate the human, but rather that owner of the email address.  The difference is import, as well as powerful, but it also adds complexity.
  % The simplest way to authenticate the owner of the email address is to use the “hack” of sending them a URL with a code every time they want to login.  However when that “hack” first became popular, email services had significant downtime, so websites did not want to be reliant on them.  So instead we relied on a scheme that had been used for user account systems that issued their own user IDs instead of relying on email address, and that scheme was passwords.
  % Combining the “hack” with passwords seemed great.  The best part was that if the user forgot their password, the website could just use the “hack” again to verify the owner of that email address and let them pick a new password.
  %



  % http://developers.soundcloud.com/docs/api/authentication#user-credentials-flow

  Selitä kertakirjautumisarkkitehtuuri, kuva~\ref{fig:kertakirjautumisarkkitehtuurin_yleiskuva}.
  \begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{images/NIST_authentication_architectural_model.jpg}
    \caption{NIST-organisaation suositus autentikoinnin arkkitehtuurimallista \cite{NIST_SP800-63-1} }
    \label{fig:kertakirjautumisarkkitehtuurin_yleiskuva}
  \end{figure}
  todo selitä kuva.


  \subsection{Tarve yhteiskäyttöiselle autentikointistandardille} % (fold)
  \label{sub:tarve_yhteiskäyttöiselle_autentikointistandardille}
  Julkinen palvelu pilvessä vs. yksityinen palvelu organisaation sisäverkossa. Erilaiset tarpeet. Miljoona erilaista toteutusta. Julkisessa pilvessä niin paljon toimijoita, että ei voi olla montaa rinnakkaista standardia, vain muutama voi levitä yhtäaikaa laajalle. Historia: Ennen oli monta sisäänkirjautumiskuvaketta (esim 20 kuvaketta tai vapaa openid-url-kenttä). Nykyisellään käytännössä vain facebook, google, twitter ehkä windows live -kuvakkeet. OpenID on olemassa mutta idea käyttäjäkeskeisyydestä on painunut taustalle. Google on edelleen OpenID, mutta sitä käytetään kuvakkeen kautta eikä omaa openid-urlia edes ole tarkoitus muistaa ulkoa (anna esimerkki). Sen sijaan Yahoo!:n ja flickrin openid-tunnuksen url on suoraan yahoo.com ja flick.com.

  % subsection tarve_yhteiskäyttöiselle_autentikointistandardille (end)

  % paragraph yleisnäkymä_ilmakuva_overview (end)

  \subsection{SAML v2.0} % (fold)
  \label{sub:saml_v2_0}
  SAML ja SOAP.

  SAML on monipuolisempi ja sitä kautta monimutkaisempi kuin OAuth ja OpenID. Viimeksimainitut toimivat lähtökohtaisesti HTTP:n avulla. SAML mahdollistaa myös muita tapoja \emph{bindings}.

  Havainto: SAML-papereissa ei puhuta mitään OAuthista tai RESTistä. Ainoastaan WS-*, Shibboleth, XACML, ID-FF (jne) mainitaan.

  SAML käyttää XML Encryption ja XML Signature -standardeja eheyden ja luotettavuuden saavuttamiseksi.
  Niiden osalta viestinvälityskerroksen (transport layer) suojaaminen ei välttämätöntä, jos WS-Security.
  HTTPS:n käyttäminen on kuitenkin yksinkertaista ja vähentää kryptografiaan aiheuttamaa kuormitus-overheadia.
  Erikseen määritellyissä tapauksissa SAML edellyttää (\emph{mandate}) viestinvälityskerroksen suojaamista SSL/TLS:llä ja viestikerroksen (message-level, todo vai onko applikaatiolevel?) suojaamista XML Encryption ja XML Signature -standardilla.

  SAML-assertiot ja SAML-protokollat määritellään pohjautuen XML Schema -standardiin.
  SAML exchanges ilmaistaan muodoltaan standardoidulla XML-murteella, josta myös SAMLin nimi on peräisin (Security Assertion Markup Language). (viite
  %http://en.wikipedia.org/wiki/Security_Assertion_Markup_Language)


  % For real, mitä eroa on OAuth ja SAML
  % https://www.pingidentity.com/resource-center/oauth-essentials.cfm
  % https://www.pingidentity.com/resource-center/SAML-Tutorials-and-Resources.cfm

  % subsection saml_v2_0 (end)

  SAML v2.0: Rakentuu Shibbolething ja Liberty ID-FF:n toiminnallisuuden päälle.

  Määrittele SAML-assertio. Onko assertio Suomea?

  SAML ja REST % http://saml.xml.org/news/how-to-use-saml-with-rest-web-services
  ''Best practice is to conform to the SAML v2 Web Profile. But the problem there is that the Web Profile relies on sessions, typically managed by cookies. Sessions are a stateful artifact that are contrary to REST.'' -- puristien mielestä joo, mutta Fielding eri mieltä: sessio on sama käyttäjälle itselleen, jolloin saman käyttäjän peräkkäiset requestit on aina restin mukaisia (sama uri+parametrit antaa aina saman vastineen).
  OAuth 2.0 sen sijaan (by design) hyödyntää HTTP-otsakkeita eikä vaadi sessiota.

  \subsubsection{SAMLin johdannaiset ja SAMLiin liittyvät tekniikat} % (fold)
  \label{ssub:samlin_johdannaiset}


  \paragraph{ID-FF} % (fold)
  \label{par:id_ff}
  Liberty Alliancen Identity Federation Frameworkin (ID-FF) pohjalla oli SAML v1.1, jonka päälle Liberty toteutti lisää toiminnallisuutta.
  Liberty Alliance tunnusti tarpeen yhdelle federated SSO:n standardille, joten Alliance tarjosi ID-FF v1.2:n takaisin OASIS-yhteisen tekniselle komitealle inputtina SAML v2.0:n rakentamiseksi.
  Libertyn nykyinen web-tunnistautumisen framework on ID-WSF, joka käyttää SAML v2.0:aa autentikointi- ja auktorisointitietojen välittämiseksi web-palvelujen välillä.

  ID-FF v1.2 ei yhteisistä juurista huolimatta ole kuitenkaan yhteensopiva SAML v2.0:n kanssa (viite https://wiki.shibboleth.net/confluence/display/SHIB/SAMLLibertyDiffs).

  % paragraph id_ff (end)

  \paragraph{Shibboleth} % (fold)
  \label{par:saml_vs_shibboleth}
  Tässä kappaleessa kerrotaan, miksi gradussa käytetään SAMLia eikä Shibbolethia. Tai sitten perustellaan miksi käytetään Shibbolethia eikä SAMLia.

  % paragraph saml_vs_shibboleth (end)

  \paragraph{XACML} % (fold)
  \label{par:xacml}
  Tässä kappaleessa kerrotaan, miksei XACML ole relevantti gradun kannalta. Liittyy auktorisointiin, jota gradu ei käsittele.

  % paragraph xacml (end)

  \paragraph{WS-Security} % (fold)
  \label{par:ws_security}
  WS-Security on OASIS-komitean standardi, joka määrittelee tavan varmistaa SOAP-viestien eheys (integrity) ja luottamuksellisuus (confidentiality) (viite saml exec overview).

  WS-Security määrittelee turvallisuuspolettien (\emph{security tokens}) käsitteen, johon WS-*-arkkitehtuurityylin tietoturvanäkökulma perustuu.
  Turvallisuuspoletti sisältää SOAP-viestiin liittyvän identiteetti- ja pääsyoikeustiedon.
  WS-Securityssä on \emph{profiileja}, jotka määrittelevät yksityiskohdat turvallisuuspoletin käyttämiselle ja turvallisuuspoletin formaatin (todo käsite).
  Tuettuja formaatteja ovat esimerkiksi X.509-sertifikaatit (todo käsite) ja Kerberos-lipukkeet (Kerberos tickets, todo käsite).

  SAML Token Profile määrittelee SAML-assertioiden käytön WS-Securityn turvallisuuspolettina (viite saml exec overview).
  SAML-standardi esittää WS-Securityn hyväksyttynä menetelmänä suojata SOAP-viestit, jotka kuljettavat SAML-protokollatietoja tai -assertioita.

  % Jos transport layer security niin WSS:ä ei tarvita yhteyden suojaamiseen. Vähentää silloin myös overheadia jos ei WSS-kryptoa.
  % Saatetaan tarvita jos SAML vaikka HTTPS?

  % paragraph ws_security (end)
  % subsection samlin_johdannaiset (end)

  \subsubsection{Kertauloskirjautuminen (Single-Sign Off)} % (fold)
  \label{ssub:kertauloskirjautuminen}
  Kerrotaan lyhyestä kertauloskirjautumisen idea ja toteutusperiaate. Miksi hyvä juttu.

  Ei tehdä graduun, ei relevantti: jos kirjaudut ulos moocista, kirjaudut ulos Facebookista, Googlesta tai kaikista HY:n järjestlemistä; ei tarpeen.
  % subsubsection kerta (end)


  \subsection{OpenID v2.0} % (fold)
  \label{sub:openid}

  OpenID:n lähtökohtana on mahdollisuus käyttää samaa identiteettiä (käyttäjätunnusta) kaikkissa web-palveluissa. OpenID-protokolla on suunniteltu siten, ettei identiteetin kuluttajan (palvelu) tarvitse tuntea identiteetintarjoajaa etukäteen. Tämän ansiosta protokolla toteuttaa käyttäjäkeskeisen identiteetin periaatteen, jossa käyttäjä voi vapaasti valita oman identiteetintarjoajansa~\cite{openid_recordon_2009}. Käytännössä tilanne on kuitenkin toinen: maailman XXX suosituimmasta OpenID:tä tukevasta web-palvelusta ainoastaan XXX hyväksyy vapaavalintaisen OpenID-identiteetintarjoajan. Yleisin tapa julkisen webin kertakirjautumiseen on hyväksyä vain palvelun taustalla olevan yrityksen oma identiteetintarjoaja tai suppea lista esivalittuja identiteetintarjoajia (kuva~\ref{fig:yahoo_login}). Tällöin käyttäjä ei myöskään näe, millä tekniikalla autentikoiminen tapahtuu.

  \begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{images/yahoo_login.jpg}
    \caption{Sisäänkirjautuminen Yahoo!-palveluun. Kaksi esivalittua identiteetintarjoajaa oman lisäksi.}
    \label{fig:yahoo_login}
  \end{figure}

  Identiteetin kuluttajan palvelussa loppukäyttäjän profiiliin kytketään käyttäjän identiteetin yksilöivä OpenID-identiteetti. Yksikään identiteetin kuluttaja ei tunne käyttäjän salasanaa, vaan ne luottavat identiteetintarjoajan viestiin siitä, että käyttäjän esittämä OpenID-identiteetti on hänen hallinnassaan.  Identiteetin todentaminen käynnistyy etsintävaiheella (\emph{discovery phase}), jossa käyttäjän syöttämän OpenID-päätepisteen (\emph{endpoint}) perusteella etsitään OpenID-tunnisteen identiteetintarjoaja. Käytännössä OpenID-päätepisteenä toimii joko OpenID-käyttäjätunnus tai identiteetintarjoajan kiinteä URL-osoite.

  Käyttäjäkeskeisen identiteetin toteutuksessa on tyypillistä etsiä OpenID-päätepiste käyttäjätunnuksen perusteella. OpenID-käyttäjätunnus on URL-osoite kuten esimerkiksi \verb!https://petrusrepo.myopenid.com!, \verb!https://myopenid.com/repo! tai
  % todo tsekkaa rivitys
  \\ \url{https://petrus.repo.fi}. Tällöin identiteetin kuluttaja aloittaa etsintävaiheen ottamalla yhteyden käyttäjätunnuksen URL-osoitteeseen. Esivalittujen identiteetintarjoajien toteutuksessa on tyypillistä, että identiteetintarjoaja suosittelee oman logonsa asettamista identiteetin kuluttajan sisäänkirjautumissivulle (kuva~\ref{fig:yahoo_login}). Tällöin identiteetintarjoajan OpenID-päätepiste on tyypillisesti hankalasti ulkoamuistettava kuten Googlella
  % todo tsekkaa rivitys
  \\ (\url{https://www.google.com/accounts/o8/id}) tai suoraan identiteetintarjoajan pääsivu kuten Yahoolla (\verb!https://yahoo.com! tai \verb!https://flickr.com!).

  Käyttäjäkeskeinen OpenID-identiteetintarjoaja ei ole lähtökohtaisesti luotettu, koska kuka tahansa voi ryhtyä OpenID-identiteetintarjoajaksi. OpenID-etsintävaiheen ansiosta identiteetin kuluttajan ei tarvitse tuntea identiteetintarjoajaa etukäteen. Identiteetin kuluttaja voi myös hyväksyä ainoastaan yhden esivalitun identiteetintarjoajan tai listan sellaisista. Hyväksymällä esimerkiksi pelkästään Google, Facebook ja Windows Live identiteetintarjoajiksi saavutetaan XX \% internetin käyttäjistä (todo luku ja viite). Hyväksymällä ainoastaan yksi identiteetintarjoaja kyseessä on federoitu identiteetti, koska käyttäjällä ei ole enää mahdollisuutta itse valita identiteetintarjoajaansa.

   OpenID-identiteetin todentaminen osoittaa ainoastaan, että jokin OpenID-identiteetti on käyttäjän hallinnassa. OpenID-identiteetillä on yksilöivä tunniste, joka rekisteröidään käyttäjän profiiliin identiteetin kuluttajan palvelussa. Yksilöivä tunniste voi olla ulkoamuistettava URL, josta annettiin esimerkkejä edellisessä kappaleessa. Sen sijaan esimerkiksi Googlen yksilöivä OpenID-tunniste on muotoa
  % todo tsekkaa rivitys
  \\ \verb#https://www.google.com/accounts/o8/id?id=<satunnaismerkkijono>#
  Google on tarkoituksellisesti halunnut häivyttää URL:n käyttämisen OpenID-tunnuksena taustalle tarjoamalla työläästi ulkoamuistettavan päätepiste- ja tunnisteosoitteen. Googlen näkemyksen mukaan käyttäjätunnuksena kannattaa ennemmin suosia sähköpostiosoitetta~\cite{google_best_practices_authentication} ja Googlen lisäksi myös Yahoon mukaan autentikoituminen on käyttäjäystävällisempää identiteetintarjoajan logon ja nimen sisältävän kuvan kuin vapaavalintaisen syöttökentän kautta~\cite{google_usability_federated_login, yahoo_usability_openid_2008, google_thoughts_combining_ux_2008a}.

  Käyttäjäkeskeisen identiteetti toteutuisi ihanteellisesti siten, että käyttäjän OpenID-tunniste olisi hänen omassa hallinnassaan. Tällöin tunnisteena olisi käyttäjän oma verkkotunnus kuten \url{https://petrus.repo.fi} tai sähköpostiosoite \url{petrus@repo.fi}. Oman verkkotunnuksen voi säilyttää hallinnassaan vaikka sukupolvelta toiselle, kun taas yrityksen nimeen kytketty verkkotunnus saattaa poistua käytöstä esimerkiksi yrityksen lopettaessa toimintansa. Tällöin myös käyttäjän identiteetin OpenID-tunniste muuttuu, jos siinä on käytetty lopettaneen yrityksen käytöstä poistuvaa verkkotunnusta. Lukuisat OpenID-identiteetintarjoajat mahdollistavat oman verkkotunnuksen käytön OpenID-tunnisteessa -- esimerkiksi Google Apps, Windows Live ja Yahoo!. Jos identiteetintarjoaja ei suoraan mahdollista oman verkkotunnuksen käyttöä, se voi silti olla mahdollista OpenID-delegoinnilla.

  \subsubsection{OpenID-autentikoinnin vaiheet} % (fold)
  \label{ssub:openid_autentikoinnin_vaiheet}

  Tässä selitetään OpenID-autentikoinnin vaiheet (kuva~\ref{fig:basic_openid_flow}).

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/openid_flow_recordon06.jpg}
    \caption{OpenID-autentikoinnin vaiheet~\cite{openid_recordon_2009} (todo en pidä tästä kuvasta, piirrä parempi)}
    \label{fig:basic_openid_flow}
  \end{figure}

  Määrittele termit speksistä: identifier, claimed identifier, verified identifier, identity provider.
  Puhutaanko aina identiteetin kuluttajasta vai pitäisikö käyttää myös termiä relying party?

  ''How the End User authenticates to their Identity Provider is outside of the scope of OpenID Authenticaiton.'' (viite speksi)

  % XRDS Discovery https://sites.google.com/site/oauthgoog/fedlogininterp/openiddiscovery


  % subsubsection openid_autentikoinnin_vaiheet (end)

  \subsubsection{Identiteetin delegointi} % (fold)
  \label{ssub:identiteetin_delegointi}

  Selitetään mahdollisuus kytkeä oma verkkotunnus kolmannen osapuolen identitarjoaan delegoimalla identiteetti.

  Käyttäjä --identiteetti--> verkkotunnus --delegointi--> idp jossa login

  \begin{verbatim}
    <head>
    <link rel="openid2.provider"
      href="https://openid.stackexchange.com/openid/provider">
    <link rel="openid2.local_id"
      href="https://openid.stackexchange.com/user/a0cd3405-f76e-429e-b935">
    </head>

    todo viite http://blog.stackoverflow.com/2009/01/using-your-own-url-as-your-openid/
  \end{verbatim}

  Oman verkkotunnuksen hosting pitää olla turvallinen. Delegointia voi muuttaa jos pääsee käsiksi verkkotunnuksen tarjoamaan delegoinnin web-sivuun.
  Google ei tästä syystä tue delegointia.
  % subsubsection identiteetin_delegointi (end)


  % Google:
  % Guide to Running a User Account System
  % http://goo.gl/R8pMP

  % subsection openid (end)

  % \subsection{OpenID Connect} % (fold)
  % \label{sub:openid_connect}
  % OpenID Connect: yhdistää tiedon jakamisen (oauth) ja autentikoitumisen (openid)
  %
  % http://www.webmonkey.com/2010/05/new-openid-connect-proposal-could-solve-many-of-the-social-webs-woes/
  %
  %
  % Mitä eroa on OpenID Connect ja OAuth 2.0 ?
  % OAuth - palvelujen täytyy tuntea toisensa. Täytyykö OpenID-C:ssa?
  % Onko OpenID-C edelleen user-centric id?
  %
  % Mikä on OpenID Abstract Binding ? (https://www.pingidentity.com/resource-center/openid.cfm)
  %
  % The current OpenID version is 2.0. However a new version, OpenID AB/C, merges two different next-generation standards efforts, OpenID Abstract Binding and OpenID Connect, and is under construction. OpenID is a profiled protocol for the Federal ICAM initiative. OpenID 2.0 is only profiled for the lowest level of assurance described by the government guidance set out in NIST 800-63. Hopefully, the next generation of OpenID will be capable of all four assurance levels used today.
  %
  % Federal Identity, Credentialing, and Access Management % http://www.idmanagement.gov/documents/ICAM_OpenID20Profile.pdf
  %
  % ks http://stackoverflow.com/questions/3260557/openid-is-the-identifier-url-unique-what-are-the-differences-between-the-ident
  %
  % subsection openid_connect (end)


  \subsection{OAuth v2.0} % (fold)
  \label{sub:oauth}

  \begin{quote}
    ''Many luxury cars come with a valet key. It is a special key you give the parking attendant and unlike your regular key, will only allow the car to be driven a short distance while blocking access to the trunk and the onboard cell phone. Regardless of the restrictions the valet key imposes, the idea is very clever. You give someone limited access to your car with a special key, while using another key to unlock everything else.''
    todo viite http://hueniverse.com/2010/05/introducing-oauth-2-0/
  \end{quote}



  OAuth 1.0 syntyi sosiaalisen median tarpeesta jakaa käyttäjän dataa eri palvelujen kesken. Ennen OAuthia oli yleistä, että esimerkiksi Facebookista käyttäjän tietoja hakenut palvelu kysyi käyttäjän omaa Facebook-salasanaa ja käytti sitä tietojen noutamiseen. Tällaista voidaan kutsua salasana-antipatterniksi, koska käyttäjän salasana ei ole jakamisen jälkeen enää salainen: jokainen Facebookista tietoa hakeva palvelu tuntee käyttäjän salasanan. OAuth 1.0:n mahdollisti luvan kysymisen käyttäjältä ennen tietojen jakamista kolmannen osapuolen palvelun kesken. Kuitenkin ennen kaikkea sisäänkirjautuminen tehtiin ainoastaan dataa hallinnoivaan palveluun eikä salasanaa tarvinnut enää syöttää kolmannen osapuolen palveluun. Tällöin esimerkiksi pääsyoikeutta käyttäjän kuviin halunnut palvelu ohjasi käyttäjän Facebookiin, jonne käyttäjä syötti salasanansa. Sen jälkeen käyttäjällä oli mahdollisuus hyväksyä tai hylätä tämä käyttöoikeuspyyntö.

  Kolmannen osapuolen palvelu K voi siis pyytää käyttäjän tietoja palvelusta P ilman että P:n salasanaa tarvitsee syöttää K:hon. Käyttäjän täytyy hyväksyä tietojen pyytäminen, eli K ei saa noudetuksi P:n tietoja ilman käyttäjän lupaa.
  OAuth 2.0 on kokonaan uusi protokolla, joka ei ole taaksepäin yhteensopiva aiempien versioiden kanssa. OAuth 2.0 on vielä tätä tutkielmaa kirjoitettaessa luonnosvaiheessa (draft 22), mutta lopullinen versio valmistunee vuoden 2012 aikana. OAuth 1.0 syntyi pitkälti Twitterin ja Googlen omien auktorisointiprotokollien pohjalta. OAuth 2.0 on saanut merkittävästi vaikutteita Facebookilta, jonka valtaisan tietomäärän eri käyttötapauksiin aiempi OAuth 1 -standardi ei millään riittänyt. OAuth 1.0 + Facebook Connect --> OAuth 2.0. Auktorisoinnin lisäksi OAuth 2.0 tukee aiempaa versiotaan selvemmin myös autentikointia.

  OAuth 1.0 tuotti vastutusta kehittäjien keskuudessa. Ennen OAuthia esimerkiksi Twitter-integraatio onnistui HTTP Basic -autentikaatiolla, mikä mahdollisti käyttäjätietojen kyselyn yhdellä HTTP-pyynnöllä (todo footnote \verb#GET http://tunnus:salasana@palvelu.com/osoite#). OAuth 1.0 monimutkaisti järjestelyä merkittävästi, koska ulkopuolisella kehittäjällä ei ollut enää pääsyä käyttäjän salasanaan ja, erityisesti, koska tietoja ei pystynyt enää hakemaan ilman käyttäjän lupaa.

  Käyttäjälle muutos on kuitenkin positiivinen, koska kohdepalvelun salasanaa ei tarvitse jakaa kolmannelle osapuolelle. Jakammalla oman salasanansa kolmannen osapuolen palveluun, käyttäjä samalla antaa tälle palvelulle täydet oikeudet salasanansa suojaamiin resursseihin. Tällöin minkä tahansa kolmannen osapuolen tietomurto vaarantaa näiden resurssien kaiken datan, joka on suojattu kyseisellä salasana. Seurauksena ainoa tapa poistaa kolmannen osapuolen pääsyoikeus jälkikäteen on salasanan vaihtaminen. Tällöin kuitenkin pääsy estyy \emph{kaikilta} palveluilta, jotka ottavat resurssiin yhteyttä kyseisellä salasanalla.

  OAuth eriyttää toisistansa roolit resurssin omistajalle (käyttäjälle) ja resurssiin yhteyttä ottavalle kolmannen osapuolen palvelulle sekä luo näiden väliin auktorisointikerroksen (\emph{authorization layer})~\cite{ietf_oauth2}. OAuth-protokollassa asiakas (\emph{client}, esim. kolmannen osapuolen palvelu) pyytää pääsyoikeutta resurssiin, jota hallinnoi resurssin omistaja ja isännöi (todo: hosting suomeksi?) resurssin palvelin. Resurssin palvelimen käyttämä OAuth-auktorisointipalvelu (\emph{authorization server} luo resurssin omistajan hyväksynnällä jokaiselle asiakkaalle (kolmannen osapuolen palvelulle) itsenäisen valtakirjan. Yhden asiakkaan valtakirjan (pääsyoikeuksien) evääminen ei vaikuta muille asiakkaille myönnettyihin tai resurssin omistajan pääsyoikeuksiin. Tällaista valtakirjaa OAuth kutsuu pääsyoikeuspoletuksi (\emph{access token}, todo käännös).

  Asiakas ei tunne resurssin omistajan salasanaa, vaan esittää pääsyoikeuspoletin saadakseen käyttöoikeuden kohteena olevaan resurssiin. Pääsyoikeuspoletti sisältää tiedon kolmannelle osapuolelle myönnettyjen oikeuksien laajuudesta sekä oikeuksien voimassaoloajasta. Tällöin resurssin omistajalle on mahdollista tarjota näkyvyys siihen, minkä resurssien jakamiseen hän on myöntänyt luvan (todo kuva auktoroisoiduista sovelluksista). Facebookin Developer -sivustolla huomautetaan kolmannen osapuolen kehittäjiä, että mitä laajempaan joukkoon resursseja pyydetään käyttöoikeutta, sitä suurempi on oikeuksien myöntämisestä kieltäytyvä käyttäjäjoukko (todo lähdeviite https://developers.facebook.com/docs/authentication/). Tämä on merkittävä havainto, koska OAuthia edeltäneenä aikana oikeuksia ei käytännössä ollut mahdollisuutta rajata lainkaan, vaan kolmannen osapuolen palvelu pystyi tekemään saamallaan käyttäjän salasanalla mitä vain.

  OAuth on suunniteltu toimimaan ainoastaan HTTP-protokollalla~\cite{ietf_oauth2}.
  Standardi jättää määrittelemättä OAuthin käytön muulla kuin HTTP-protokollalla.


  Selitä auki kuva~\ref{fig:facebook_oauth_lupapyynto}.

  \begin{figure}
    \centering
    \includegraphics[width=1.0\textwidth]{images/facebook_oauth_lupapyynto.jpg}
    \caption{OAuth-käyttöoikeuspyyntö Facebookissa. Osoiterivillä dataa hallinnoivan palvelun URL ja selainkontekstin turvallisuusilmoitus.}
    \label{fig:facebook_oauth_lupapyynto}
  \end{figure}

  Soundcloud OAuth authorization flow diagram % http://developers.soundcloud.com/docs/api/authentication#authorization-code-flow

  Kerro miksi hueniverse on mainio lähde; blogia pitää yksi oauth-speksin kehittäjistä

  auktorisointiluvan kysyminen mobiilissa.

  Onko OAuth 2.0 sama REST-palveluille kuin WS-Trust and WS-Security for SOAP -palveluille? (https://www.pingidentity.com/resource-center/oauth-essentials.cfm)

  Kaaviokuva / sanallinen dialogi autentikaatiosta ennen oauth1.0, oauth2.0, palvelin-palvelin
  ks. Internet-Scale Identity Systems: An Overview and Comparison

  Oauth-identiteetti on tiukasti kytketty tiettyyn palveluntarjoajaan (esim. Facebook).
  Ei ole käyttäjäkeskeinen: Käytettävän palvelun (identity consumer) on tuettava tiettyä palvelua esim tarjoamalla siihen liittyvä kuvake.
  ''Before initiating the protocol, the client registers with the authorization server. The means through which the client registers with the authorization
  server are beyond the scope of this specification, but typically involve end-user interaction with an HTML registration form.'' (viite: ''client registration'' \cite{ietf_oauth2})

  Mahdollistaa ennakkoon rekisteröitymättömät asiakkaat: kpl 2.4 ''This specification does not exclude the use of unregistered clients. However, the use with
  such clients is beyond the scope of this specification,...''
  3.1.2.2 registration requirements:
    Public ja Confidential clients utilizing the implicit grant type MUST register prior to using the authorization endpoint.


  Facebook OAuth dialogs: https://developers.facebook.com/docs/reference/dialogs/oauth/

  OAuth mahdollistaa http basic autentikoinnin (kpl 2.3.1) ennen auktorisointia.
  Draft vaatii HTTPS:n ja brute-force suojauksen:
    ''The authorization server MUST require the use of a transport-layer
     security mechanism when sending requests to the token endpoint, as
     requests using this authentication method result in the transmission
     of clear-text credentials.

     Since this client authentication method involves a password, the
     authorization server MUST protect any endpoint utilizing it against
     brute force attacks.''

  Vaatii aina autentikoitumisen (3.2.1. Client Authentication) tietyissä tapauksissa.

  Tietomurrosta toipuminen (3.2.1):
  ''Changing a single set of client credentials is significantly faster than revoking an entire set of refresh tokens.''
  ''Rotation of an entire set of refresh tokens can be challenging, while rotation of a single set of client credentials is significantly easier.''

  9. Native Authentication:
  ''When choosing between an external or embedded user-agent, developers should consider: [..]''

  10. Client Authentication
  Hyvä kappale eri tietoturvanäkökulmista ja uhkakuvista.
  OAuth ja MITM:
  - 10.6.  Authorization Code Redirection URI Manipulation
  - 10.9.  Endpoints Authenticity
  - 10.11.  Phishing Attacks


  OAuth draft kpl 2.1:
  OAuth Client Types: confindential/public
  OAuth Client Profiles: Web Application, user-agent-based application, native application

  Endpointit: kpl3.1
   The authorization endpoint is used to interact with the resource
      owner and obtain an authorization grant.  The authorization server
      MUST first verify the identity of the resource owner.
   Autentikointimenetelmään ei ota kantaa.
   Edellytetään HTTPS:ää (''The authorization server MUST support TLS 1.0 ([RFC2246]), SHOULD support TLS 1.2 ([RFC5246]) and its future'')
   ks. myös 3.1.2.1 HTTPS
  http://tools.ietf.org/html/draft-ietf-oauth-v2-22

  http://tools.ietf.org/html/draft-ietf-oauth-v2-threatmodel-01

  http://hueniverse.com/2010/05/introducing-oauth-2-0/
  ''OAuth is a security protocol that enables users to grant third-party access to their web resources without sharing their passwords.''
  ''OAuth includes two main parts: obtaining a token by asking the user to grant access, and using tokens to access protected resources. The methods for obtaining an access token are called flows.''
  ''Bearer tokens: OAuth 2.0 provides a cryptography-free option for authentication which is based on existing cookie authentication architecture. Instead of sending signed requests using HMAC and token secrets, the token itself is used as a secret sent over HTTPS. This allows making API calls using cURL and other simple scripting tools without having to canonicalize the request and sign it.''
  ''Short-lived tokens with Long-lived authorizations: Instead of issuing a long lasting token (typically good for a year or unlimited lifetime), the server can issues a short-lived access token and a long lived refresh token. This allows clienta to obtain a new access token without having to involve the user again, but keeps access tokens limited. This feature was adopted from Yahoo!’s BBAuth protocol and later its OAuth 1.0 Session Extension.''

  ''This has been a sore point from the beginning with people arguing whether OAuth is an authentication protocol or an authorization protocol, with the word ‘delegation’ being used as a compromise. The truth is, OAuth contains both. The redirection-based flow is authorization (with user authentication left intentionally out of scope), and the signature flow is authentication. By separating the two, OAuth becomes more modular and easier to understand.'' http://hueniverse.com/2009/11/planning-for-oauth-2-0/

  ''Over the past few weeks, we determined that OAuth is now a mature standard with broad participation across the industry. In addition, we have been working with Symantec to identify issues in our authentication flow to ensure that they are more secure. This has led us to conclude that migrating to OAuth \& HTTPs now is in the best interest of our users and developers. (11.5.2011, https://developers.facebook.com/blog/post/497/)''


  \subsubsection{OAuth-tokenit} % (fold)
  \label{ssub:oauth_tokenit}

  % subsubsection oauth_tokenit (end)

  \subsubsection{OAuth-flowt} % (fold)
  \label{ssub:oauth_flowt}
  http://code.google.com/apis/accounts/docs/OAuth2WebServer.html

  https://developers.facebook.com/docs/authentication/


  % subsubsection oauth_flowt (end)


  % http://fireeagle.yahoo.net/developer/documentation/using_oauth
  %
  % http://developers.soundcloud.com/docs/api/authentication#refreshing
  % Once an access_token is expired you can use the refresh_token to obtain a new one:
  %
  % $ curl "https://api.soundcloud.com/oauth2/token" \
  %            -d 'client_id=YOUR_CLIENT_ID' \
  %            -d 'client_secret=YOUR_CLIENT_SECRET' \
  %            -d 'grant_type=refresh_token' \
  %            -d 'refresh_token=04u7h-r3fr35h-70k3n'
  % {
  %   "access_token": "04u7h-4cc355-70k3n-2",
  %   "expires_in": 3600,
  %   "scope": null,
  %   "refresh_token": "04u7h-r3fr35h-70k3n-2"
  % }

  % Using a Refresh Token
  % http://code.google.com/apis/accounts/docs/OAuth2ForDevices.html
  %
  % POST /o/oauth2/token HTTP/1.1
  % Host: accounts.google.com
  % Content-Type: application/x-www-form-urlencoded
  %
  % client_id=812741506391-h38jh0j4fv0ce1krdkiq0hfvt6n5amrf.apps.googleusercontent.com&
  % client_secret={clientSecret}&
  % code=4/L9fTtLrhY96442SEuf1Rl3KLFg3y&
  % grant_type=http://oauth.net/grant_type/device/1.0
  %
  % If the user has not yet approved the request, the response will appear as follows:
  % {
  %   "error" : "authorization_pending"
  % }
  % Your application should repeat these requests at the rate that does not exceed the value of interval field. If your application polls too quickly, then the response will appear as follows:
  % {
  %   "error" : "slow_down"
  % }
  % Once the user logs in and grants your application access to a Google API, the next polling request will result in an access and refresh token (shown below).
  % {
  %   "access_token" : "ya29.AHES6ZSuY8f6WFLswSv0HELP2J4cCvFSj-8GiZM0Pr6cgXU",
  %   "token_type" : "Bearer",
  %   "expires_in" : 3600,
  %   "refresh_token" : "1/551G1yXUqgkDGnkfFk6ZbjMLMDIMxo3JFc8lY8CAR-Q"
  % }
  % Upon receipt of this response, your application may use the access token in Google API requests. Access tokens have a limited lifetime. If your application needs access to an API over a long period of time, then it can use the refresh token to obtain a new access token (see Using a refresh token). If your application needs this type of access, then it should store the refresh token for later use.
  %
  % Access tokens expire. An API will indicate that an access token has expired when it returns a 401 status code. To obtain a new access token, make a request to the token endpoint and include the client_id, client_secret, refresh_token, and grant_type parameters (shown below).
  % POST /o/oauth2/token HTTP/1.1
  % Host: accounts.google.com
  % Content-Type: application/x-www-form-urlencoded
  %
  % client_id=812741506391-h38jh0j4fv0ce1krdkiq0hfvt6n5amrf.apps.googleusercontent.com&
  % client_secret={clientSecret}&
  % refresh_token=1/551G1yXUqgkDGnkfFk6ZbjMLMDIMxo3JFc8lY8CAR-Q&
  % grant_type=refresh_token

  % subsection oauth (end)


  \subsection{Tekniikoiden yhtäläisyydet} % (fold)
  \label{sub:tekniikoiden_yhtäläisyydet}

  Sen jälkeen kun eri tekniikat on selitetty, yhteenvetokappaleeseen taulukko jossa parilla lauseella selitetään jokainen.
  + Voi olla toinenkin taulukko, jossa esim. front channel ja back channel jokaisen protokollan osalta.
  + Trust Model: RP/SP initiated; IDP initieated %; (esim definition of trust: "A reasonable expectation of confidence in an actor’s behavior")
  + Registration / Discovery % ("Discovery is similar to a Web search for an identity."; "Discovery can be preceded by a registration step: a step by which IDPs register themselves as providing a particular identity service for a given user. Such a registry could be located on the client or on a network endpoint.")

    % http://stackoverflow.com/questions/7699200/what-is-the-difference-between-openid-and-saml
    % SAML2 supports single sign-out - but OpenID does not
    % SAML2 service providers are coupled with the SAML2 Identity Providers, but OpenID relying parties are not coupled with OpenID Providers. OpenID has a discovery protocol which dynamically discovers the corresponding OpenID Provider, once an OpenID is given.
    % With SAML2, the user is coupled to the SAML2 IdP - your SAML2 identifier is only valid for the SAML2 IdP who issued it. But with OpenID, you own your identifier and you can map it to any OpenID Provider you wish.
    % SAML2 has different bindings while the only binding OpenID has is HTTP
    %
    %
    \begin{figure}
      \centering
      \includegraphics[width=0.9\textwidth]{images/kertakirkautumistekniikat_venn.jpg}
      \caption{Yleiskuva kertakirjautumistekniikoiden yhtenäisyyksistä}
      \label{fig:yleiskuva}
    \end{figure}


  % subsection tekniikoiden_yhtäläisyydet (end)


% section Kertakirjautumisstandardit (end)


\section{Case MOOC: Vertailu kertakirjautumisjärjestelmien soveltuvuusalueista} % (fold)
\label{sec:mooc_vertailu}

  Helsingin yliopiston tietojenkäsittelytieteen laitos järjestää ohjelmoinnin avointa virtuaaliopetusta. Opetus tapahtuu niin sanotussa Massive Online Open Course (MOOC) -formaatissa (todo alaviite), jossa kuka tahansa ja mistä päin maailmaa tahansa voi hyväksytysti suorittaa kurssiin. Opiskelijalla ei tarvitse olla Helsingin yliopiston opiskeluoikeutta eikä siten myöskään Helsingin yliopiston verkkoympäristön käyttäjätunnusta. MOOC-järjestelmä tarvitsee kuitenkin luotettavan tavan käyttäjän tunnistamiseksi.

  MOOC-palvelussa on tällä hetkellä oma tunnus ja salasana jokaiselle käyttäjälle. Käyttäjätunnus on MOOC-palvelun sisäisen toteutus, jota ei ole kytketty muihin järjestelmiin. MOOC-palvelun nykyisestä toteutuksesta eli omasta tunnus/salasana-yhdistelmästä halutaan eroon. Nykyisellään autentikointia ei ole erotettu SOA-arkkitehtuurimallin mukaisesti omaksi palvelukseen, vaan autentikoinnin toteutus on kytketty tiukasti (\emph{tightly coupled}) muun palvelun toteutukseen.

  MOOC-järjestelmän toteutuksessa sovelletaan sekä käyttäjäkeskeisen että federoidun identiteetin periaatetta. Käyttäjäkeskeinen identiteetti toteutetaan tarjoamalla tunnistautumisvaihtoehdoiksi OpenID sekä vapaavalintaisella että esivalitulla identiteetintarjoajalla. OpenID:n vapaavalintaisen identiteetintarjoajan ansiosta avulla kuka tahansa voi rekisteröityä. Esivalittuna identiteetintarjoajana toteutetaan yksinkertaisuuden vuoksi ainoastaan Google -- muita merkittäviä vaihtoehtoja olisivat esimerkiksi Windows Live, Yahoo! ja VeriSign (todo viite http://openid.net/get-an-openid/). Federoitu identiteetti toteutuu Helsingin yliopiston opiskelijoille mahdollisuutena autentikoitua Helsingin yliopiston käyttäjätunnuksella käyttäen SAML-standardia.

  Tässä tapauksessa OAuth luokittuu käyttäjäkeskeisen ja federoidun identiteetin välille. OAuth-protokolla ei itsessään toteuta käyttäjäkeskeisen identiteetin periaatetta, mutta OAuthilla voidaan tuoda MOOC-palveluun yksi identiteetintarjoaja lisää. Käyttäjän kannalta ei ole merkitystä protokollalla vaan mahdollisuudella itse valita oma identiteetintarjoajansa. Siksi MOOC-järjestelmään tuodaan kolmantena vaihtoehtona OAuth-autentikoituminen Facebook-palveluun.

  MOOC-palvelun kannalta identiteetin myöntäneellä organisaatiolla ei ole merkitystä. Autentikoinnin vaatimuksena on varmistaa, että vain ja ainoastaan identiteetin oikea haltija pystyy osoittamaan identiteettiin liittyvän tunnisteen itselleen. Tunniste on OpenID:n tapauksessa OpenID URL, OAuthin tapauksessa XXX (johon \verb#acecss_token# kytketään) ja SAMLin tapauksessa XXX.

  Yllä mainittujen lisäksi MOOC voisi myös itse toimia identiteetintarjoajana. Tämä toteutettaisiin SOA-arkkitehtuurimallin mukaisesti itsenäisenä palvelunaan käyttäen joko OpenID tai OAuth -standardia. Erona nykytilanteeseen olisi autentikoinnin erottaminen varsinaisesta ydinpalvelusta (loosely coupled -periaate), jolloin uusien toimintojen (esimerkiksi kurssien) lisääminen tulevaisuudessa ei edellytä muutoksia MOOC-järjestelmään vaan ne voidaan toteuttaa itsenäisinä palveluinaan. Järjestelmän teknisen ja hallinnollisen ylläpidon helpottamiseksi omaa MOOC-identiteetintarjoajaa ei kuitenkaan tässä yhteydessä toteuteta.

  Tutkielma esittää toteutuksen, jossa kertakirjautuminen ei olisi mahdollinen pelkästään yhdellä yhteentoimivuuden standardilla. MOOC-palvelun toteutuksessa rinnakkaiset standardit -- OpenID, OAuth, ja SAML -- tukevat toinen toisiaan eivätkä varsinaisesti kilpaile keskenään.




  \subsection{Autentikointi Helsingin yliopiston verkkoympäristössä} % (fold)
  \label{sub:autentikointi_helsingin_yliopiston_verkkoympäristössä}

  Helsingin yliopistolla (HY) on virallinen hallinnollinen päätös keskittää kaikki autentikointi Active Directory (AD) -palveluun (todo tarvitaanko lähde?).
  Tietojenkäsittelytieteen laitoksella (TKTL) on oma AD-palvelu ja lisäksi lukuisa määrä erilaisia ja -tasoisia autentikointipalveluja.
  Sisäinen toteutus voisi olla henkilökohtaiset Kerberos-sertifikaatit (todo termi), mutta sellainen ratkaisu ei olisi yhteensopiva yliopiston AD-päätöksen kanssa, eikä se olisi siksi toteuttamiskelpoinen.

  TKTL:n ensisijainen käyttäjätietojen lähde on Helsingin yliopiston tietotekniikkaosaston käyttäjärekisteri, josta käyttäjätiedot kopioidaan eräajona TKTL:n omien autentikointipalvelujen käytettäviin. Esimerkiksi laitoksen ilmoittautumisjärjestelmä autentikoi TKTL:n LDAP-palveluun, johon käyttäjätiedot on kopioitu eräajona HY:n ensisijaisesta käyttäjärekisteristä. LDAP-sisältää käyttäjän henkilötietojen lisäksi myös hashatun (todo termi) salasanan, jota vastaan autentikoniti suoritetaan. Rinnakkaisia perinnejärjestelmiä on syntynyt ajan kanssa ja niiden integroiminen yhdeksi yhteiseksi järjestelmäksi vaatiis paljon työtä.

  Autentikointinsa puolesta MOOC-järjestelmän ei kannata ylläpitää ongelmaa, vaan olla ennemmin osa sen ratkaisua. Siksi tämän tutkielman puitteissa noudatetaan mukisematta HY:n virallista päätöstä ja valitaan Active Directory yliopiston sisäisen käyttäjätunnuksen autentikointilähteeksi. Akateemisessa ympäristössä vapaus on perusarvo, minkä vuoksi järjestelmä tukee käyttäjäkeskeistä identiteettiä eli mahdollistaa vapaavalintaisen OpenID-identiteetintarjoajan käyttämisen. Käyttäjäystävällisyyden vuoksi tarjotaan myös kaksi esiasetettua identintarjoajaa: Google (OpenID) ja Facebook (OAuth).

  % subsection autentikointi_helsingin_yliopiston_verkkoympäristössä (end)


  \subsection{Autentikoituminen federoidulla identiteetillä Helsingin yliopiston käyttäjärekisteriin} % (fold)
  \label{sub:autentikoituminen_helsingin_yliopiston_käyttäjärekisteriin}
  Tässä kerrotaan periaatetasolla, kuinka MOOC käyttää SAMLia tunnistaakseen käyttäjän yliopiston AD-palvelulla.

  Kiinnostaisi jättää tämä vähemmälle huomiolle ja keskittyä OpenID:n ja OAuthin selittämiseen.

  % subsection autentikoituminen_helsingin_yliopiston_käyttäjärekisteriin (end)

  \subsection{Autentikoituminen esiasetetulla Google OpenID -identiteetintarjoajalla} % (fold)
  \label{sub:autentikoituminen_esiasetetulla_openid_identiteetintarjoajalla}

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/google_openid_diagram.png}
    \caption{Sekvenssikaavio OpenID-autentikoinnista; Googlen suosittelema autentikointiprosessi (todo viite http://code.google.com/apis/accounts/docs/OpenID.html)}
    \label{fig:sekvenssikaavio_google_openid}
  \end{figure}

  % Kuva:
  % 1. The web application asks the end user to log in by offering a set of log-in options, including using their Google account.
  % 2. The user selects the "Sign in with Google" option. See Designing a Login User Interface for more options.
  % 3. The web application sends a "discovery" request to Google to get information on the Google login authentication endpoint.
  % 4. Google returns an XRDS document, which contains the endpoint address.
  % 5. The web application sends a login authentication request to the Google endpoint address.
  % 6. This action redirects the user to a Google Federated Login page, either in the same browser window or in a popup window, and the user is asked to sign in.
  % Once logged in, Google displays a confirmation page (redirect version / popup version) and notifies the user that a third-party application is requesting authentication. The page asks the user to confirm or reject linking their Google account login with the web application login. If the web application is using OpenID+OAuth, the user is then asked to approve access to a specified set of Google services. Both the login and user information sharing must be approved by the user for authentication to continue. The user does not have the option of approving one but not the other.
  % Note: If the user is already logged into their Google account, or has previously approved automatic login for this web application, the login step or the approval step (or both) may be skipped.
  %
  % 7. If the user approves the authentication, Google returns the user to the URL specified in the openid.return_to parameter of the original request. A Google-supplied identifier, which has no relationship to the user's actual Google account name or password, is appended as the query parameter openid.claimed_id. If the request also included attribute exchange, additional user information may be appended. For OpenID+OAuth, an authorized OAuth request token is also returned.
  %
  % 9. The web application uses the Google-supplied identifier to recognize the user and allow access to application features and data. For OpenID+OAuth, the web application uses the request token to continue the OAuth sequence and gain access to the user's Google services.
  % Note: OpenID authentication for Google Apps (hosted) accounts requires an additional discovery step. See OpenID API for Google Apps accounts.

  Googlen OpenID-päätepiste (\emph{endpoint}) löytyy lähettämällä HTTP \verb#GET# tai \verb#HEAD# -pyyntö osoitteeseen \verb#https://www.google.com/accounts/o8/id#. Tämä discovery-pyyntö (todo termi) palauttaa \verb#XRDS#-dokumentin, joka sisältää Googlen OpenID-identiteetintarjoajan päätepisteen URL:n. Identiteetintarjoajan URL ilmaistaan vastauksessa seuraavasti~\cite{google_openid_dev_docs}:

  \begin{verbatim}
    <Service priority="0">
    <Type>http://specs.openid.net/auth/2.0/server</Type>
    <URI>{Googlen OpenID-päätepisteen URL}</URI>
    </Service>
  \end{verbatim}

  Googlen OpenID-päätepiste (\verb#https://www.google.com/accounts/o8/id#) on yhteinen jokaiselle Googlen OpenID-tunnukselle, joten se ei toimi käyttäjän yksilöivänä OpenID-tunnisteena. Yksilöivä Google OpenID -tunniste on muotoa \verb#https://www.google.com/accounts/o8/id?id=<satunnaismerkkijono>#, jota käyttäjän ei ole tarkoitus edes nähdä.

  % lue http://code.google.com/googleapps/domain/sso/openid_reference_implementation.html

  % 23.1.2012
  %
  % GET https://www.google.com/accounts/o8/id HTTP/1.0
  %
  % <?xml version="1.0" encoding="UTF-8"?>
  % <xrds:XRDS xmlns:xrds="xri://$xrds" xmlns="xri://$xrd*($v*2.0)">
  %   <XRD>
  %   <Service priority="0">
  %   <Type>http://specs.openid.net/auth/2.0/server</Type>
  %   <Type>http://openid.net/srv/ax/1.0</Type>
  %   <Type>http://specs.openid.net/extensions/ui/1.0/mode/popup</Type>
  %   <Type>http://specs.openid.net/extensions/ui/1.0/icon</Type>
  %   <Type>http://specs.openid.net/extensions/pape/1.0</Type>
  %   <URI>https://www.google.com/accounts/o8/ud</URI>
  %   </Service>
  %   </XRD>
  % </xrds:XRDS>
  %


  % subsection autentikoituminen_esiasetetulla_openid_identiteetintarjoajalla (end)

  \subsection{Autentikoituminen käyttäjäkeskeisen identiteetin OpenID-toteutuksella} % (fold)
  \label{sub:autentikoituminen_käyttäjäkeskeisellä_identiteetillä}
  Tässä kerrotaan periaatetasolla, kuinka tarjotaan mahdollisuus vapaavalintaisen identiteetintarjoajan käyttämiseksi. Tekninen selitys on sama kuin luvussa, jossa kerrotaan Googlen OpenID:n soveltamisesta.
  % subsection autentikoituminen_käyttäjäkeskeisellä_identiteetillä (end)


  \subsection{Autentikoituminen OAuth-toteutuksella} % (fold)
  \label{sub:autentikoituminen_oauth}
  Tässä kerrotaan kuinka Facebook-autentikoinnilla pääsee MOOC-palveluun.

  Päälähteenä Facebookin kehittäjädokumentaatio:
  \\ \verb!https://developers.facebook.com/docs/authentication/!

  % subsection autentikoituminen_oauth (end)

  \subsection{Jatkokehitysideoita} % (fold)
  \label{sub:jatkokehitysideoita}

  \subsubsection{Auktorisointi} % (fold)
  \label{ssub:jatkokehitysideoita_auktorisointi}
  MOOC tarjoaa mahdollisuuden antaa opintosuoritusote lukioon. MOOC hakee suoritusotteen Oodista. Auktorisointiin käytetään OAuthia: luvan antaminen edellyttää että käyttäjä itse sallii MOOC-järjestelmän pääsyn Oodissa oleviin käyttäjätietoihinsa.

  On myös mahdollista tarjota MOOC-suorituksista raportti lukioon siten, että MOOC tukee OAuthia ja tarjoaa ulkoisen rajapinnan tietojen noutamiseksi. Tällöin lukion tietojärjestelmä voi hakea käyttäjän MOOC-suoritukset OAuth-valtuutuksella, joka voi olla joko käyttäjän hyväksyttävä TAI sitten palvelin-palvelin-yhteydelle aina hyväksytty (implisiittinen ja sit se toinen tapa).

  Auktorisointi: Käyttäjän yhteystiedot, profiilikuva jne Facebookista.

  \begin{figure}
    \centering
    \includegraphics[width=0.9\textwidth]{images/facebook_authorization_contact_info.png}
    \caption{Luvan kysyminen OAuthilla tietojen noutamiseksi Facebookista (todo viite https://developers.facebook.com/blog/post/446)}
    \label{fig:yleiskuva}
  \end{figure}



  % Sovella hyvä selitys, myös resurssit: http://developers.soundcloud.com/docs/api/authentication
  % Miksi MOOC resurssipohjainen eikä ws-* ?

  Entäs MOOC Mobiili? % https://dev.twitter.com/docs/auth/mobile-sign-flow

  % Käyttökokemus: http://benward.me/blog/oauth-flow
  % Best practices: http://fireeagle.yahoo.net/developer/documentation/oauth_best_practice

  % subsubsection jatkokehitysideoita_auktorisointi (end)

  \subsubsection{Yliopiston palvelut julkiseen pilveen} % (fold)
  \label{ssub:yliopiston_sähköpostit_pilveen}

    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.9\textwidth]{images/google_saml_workflow_vertical.png}
      \caption{Autentikoituminen Helsingin yliopiston käyttäjärekisterillä Googleen. Tällöin esim. yliopiston sähköpostipalvelu, kalenteri ja dokumentit voitaisiin ulkoistaa julkiseen pilveen. Tällöin Googlea voisi käyttää OpenID-proxynä eli autentikoitua Helsingin yliopiston käyttäjätunnuksella mihin tahansa verkkopalveluun, joka tukee OpenID:tä.}
      \label{fig:hy_julkiseen_pilveen}
    \end{figure}

    Yliopiston palvelut julkiseen pilveen, ks kuva~\ref{fig:hy_julkiseen_pilveen}
    todo viite \url{http://code.google.com/googleapps/domain/sso/saml_reference_implementation.html}

  % subsubsection yliopiston_sähköpostit_pilveen (end)

  % subsection jatkokehitysideoita (end)



  \subsection{Yhteenveto toteutuksesta} % (fold)
  \label{sub:yhteenveto_toteutuksesta}

  Sen jälkeen kun eri tekniikat on selitetty, yhteenvetokappaleeseen taulukko jossa parilla lauseella selitetään jokainen.
  + Voi olla toinenkin taulukko, jossa esim. front channel ja back channel jokaisen protokollan osalta.
  + Trust Model: RP/SP initiated; IDP initieated; (esim definition of trust: A reasonable expectation of confidence in an actor’s behavior)
  + Registration / Discovery (Discovery is similar to a Web search for an identity.; Discovery can be preceded by a registration step: a step by which IDPs register themselves as providing a particular identity service for a given user. Such a registry could be located on the client or on a network endpoint.)

  % subsection yhteenveto_toteutuksesta (end)




% section kertakirjautumisjärjestelmien_ (end)

\section{Yhteenveto} % (fold)
\label{sec:yhteenveto}

  Gradun tavoite on täyttynyt, jos koodinimi ''Tienaria'' edustava Luukkainen pystyy kertomaan, mitä eroa ja yhteisiä piiretitä on SAMLilla, OAuthilla ja OpenID:llä.

% section yhteenveto (end)

\bibliographystyle{tktl}
\bibliography{g}

\lastpage

\end{document}